# 工厂模式

如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择。

将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式。

如果需要根据具体场景创建不同实例，这些实例都有相同的行为，这时候我们可以使用工厂模式。


# 优点

- 创建对象的过程可能很复杂，但我们只需要关心创建结果。

- 构造函数和创建者分离, 符合“开闭原则”

- 一个调用者想创建一个对象，只要知道其名称就可以了。

- 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。



# 例子一

- 由外面传参决定开启哪一条生产线。

```js
class Product1 {
  product() {
    console.log("生产一线");
  }
}
class Product2 {
  product() {
    console.log("生产二线");
  }
}
class Factory {
  constructor() {
    this.Product1 = Product1;
    this.Product2 = Product2;
  }
  create(name, callBack) {
    const product = new this[name]();
    product.product();
    return callBack("susess");
  }
}
let p = new Factory();
p.create("Product1", (res) => {
  console.log(res);
})
```


# 例子二

- JQuery的 $() 就是一个工厂函数，它根据传入参数的不同，创建元素或寻找元素

```js
class jQuery {
    constructor(selector) {
        super(selector)
    }
    add() {
        
    }
  // 此处省略若干API
}

window.$ = function(selector) {
    return new jQuery(selector)
}
```