# 介绍

（工厂方法，抽象工厂，建造者）统称为工厂模式

前端只需要掌握核心的工厂模式即可

工厂模式是创建对象的一种方式。不用每次都自身去创建对象，而是通过一个既定的 “工厂” 来生产对象并return出去。





# demo演示工厂模式

```ts
interface IProduct {
    name: string
    fn1: () => void
    fn2: () => void
}

class Product1 implements IProduct { 
    name: string
    constructor(name: string) {
        this.name = name
    }
    fn1() { 
        alert('product1 fn1')
    }
    fn2() { 
        alert('product1 fn2')
    }
}

class Product2 implements IProduct { 
    name: string
    constructor(name: string) {
        this.name = name
    }
    fn1() { 
        alert('product2 fn1')
    }
    fn2() { 
        alert('product2 fn2')
    }
}

// 工厂
class Creator {
    // IProduct 符合依赖倒置原则 
    create(type: string, name: string): IProduct {
        if (type === 'p1') {
            return new Product1(name)
        }
        if (type === 'p2') {
            return new Product2(name)
        }
        throw new Error('Invalid type')
    }
}

// 使用
const creator = new Creator()
const p1 = creator.create('p1', 'name1')
const p11 = creator.create('p1', 'name11')
const p2 = creator.create('p2', 'name2')
```

# 解决什么问题？

- 这个工厂把判断逻辑封装了起来，创建对象的过程可能很复杂，但我们只需要关心创建结果
- 代码复用


# 符合设计原则

5 大设计原则中，最重要的就是：**开放封闭原则**，对扩展开放，对修改封闭

- 可以扩展多个类
- 工厂的创建逻辑也可以自由扩展




## 注意事项

- 遇到 `new class` 时，考虑工厂模式





# 实际场景

## jQuery `$('div')`

```ts
// 扩展
declare interface Window { 
    $: (selector: string) => JQuery
}

class JQuery {
    selector: string
    length: number

    constructor(selector: string) {
        const domList = Array.prototype.slice.call(document.querySelectorAll(selector))
        const length = domList.length
        for (let i = 0; i < length; i++) { 
            this[i] = domList[0]
        }

        this.selector = selector
        this.length = length
    }

    append(elem: HTMLElement): JQuery {
        // ...
        return this
    }

    addClass(key: string, value: string): JQuery {
        // ...
        return this
    }

    html(htmlStr: string): JQuery | string { 
        if (htmlStr) {
            // set html
            return this
        } else { 
            // get html
            const html = 'xxx'
            return html
        }
    }
}

// const jquery = {
//   selector: 'div',
//   length: 3,
//   '0': div1,
//   '1': div2,
//   '2': div3,
// }


// 非工厂模式使用
const $div = new JQuery('div')
const $p = new JQuery('p')

// 工厂模式使用
function $(selector: string) {
  return new JQuery(selector)
}
window.$ = $
const div = $('div')
const p = $('p')
```

做一个对比，如果开放给用户的不是`$`，然后让用户自己去`new JQuery(selector)`，带来的问题：

- 不方便链式操作，如`$('div').append($('#p1')).html()`
- 不宜将构造函数暴露给用户，尽量高内聚、低耦合
