# 单例模式的定义

确保只有一个实例，并提供全局访问


# 用途

主要用途是避免重复的创建实例，节约不必要的开销。

也会用在一些数据缓存、全局通用弹窗（如登录弹窗）等一些场景中



# 标准的单例模式

只有没有 instance 时才会执行初始化方法，后面再执行的时候会直接复用之前的instance，这就保证了即使函数执行了很多次，也能保证唯一实例。

```js
var Singleton = function( name ){
    this.name = name;
    this.instance = null;
};

Singleton.prototype.getName = function(){
    alert ( this.name );
};

Singleton.getInstance = function( name ){
    if ( !this.instance ){
        this.instance = new Singleton( name );
    }
    return this.instance;
};

var a = Singleton.getInstance( 'sven1' );
var b = Singleton.getInstance( 'sven2' );

alert ( a === b ); // true
```


# 惰性单例

指的是在需要的时候才创建对象实例。

只有在点击登录按钮时，才会去创建登录弹窗dom节点，并且只有在第一次执行时创建登录弹窗dom节点，再次执行也不会创建多余的节点，节省了一部分性能。

```js
var createLoginLayer = (function() {
    var div;
    return function() {
        if(!div) {
            div = document.createElement('div');
            div.innerHtml = '登录弹窗';
            div.style.display = 'none';
            document.body.appendChild(div);
        }
        return div;
    }
})()

document.getElementById('loginBtn').onclick = function() {
    var loginLayer = createLoginLayer();
    loginLayer.style.display = 'block';
}
```


# 抽离惰性单例

抽离是遵循 单一职责原则

```js
// 我们将创建登录弹窗和单例的逻辑分离成 createLoginLayer 和 getSingle，这样之后再有了类似的需求，就可以复用到 getSingle 方法实现单例。


// 通用的惰性单例
var getSingle = function(fn) {
    var result;
    return function() {
        return result || (resule = fn.apply(this, arguments));
    }
}

// 创建登录弹窗的方法就可以改写成
var createLoginLayer = function() {
    var div = document.createElement('div');
    div.innerHtml = '登录弹窗';
    div.style.display = 'none';
    document.body.appendChild(div);
    return div;
}

var createSingleLoginLayer = getSingle(createLoginLayer);

document.getElementById('loginBtn').onclick = function() {
    var loginLayer = createSingleLoginLayer();
    loginLayer.style.display = 'block';
}
```


# 单例模式应用于 axios 取消重复请求

如果接口返回较慢并且此时用户频繁切换tab，就会导致多个接口一直在响应中，但前面的筛选数据已经没有意义了


```js
import axios from "axios";
const CancelToken = axios.CancelToken;
let cancelId = 0;
let cancelArray = [];

// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // 在请求时，可以添加自己的特点标识去筛选出需要重复取消的接口
  const source = CancelToken.source();
  cancelId++;
  const id = cancelId;
  config.cancelId = id;
  config.cancelToken = source.token;
  const cancelIndex = cancelArray.findIndex(e => e.url === config.url);
  cancelArray.push({
    id,
    url: config.url,
    source
  })
  if (cancelIndex > -1) {
    cancelArray[cancelIndex].source.cancel('取消重复请求');
    cancelArray.splice(cancelIndex, 1)
  }
  return config;
}, function (error) {
  return Promise.reject(error);
});

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
  const cancelIndex = cancelArray.findIndex(e => e.id === response.cancelId);
  if (cancelIndex >= -1) {
    cancelArray.splice(cancelIndex, 1)
  }

  // 对响应数据做点什么
  return response;
}, function (error) {
  if (axios.isCancel(error)) {
    // 如果是取消的接口，可以自行返回一个特定标识
    console.log('isCancel')
  } else {
    // 对响应错误做点什么
    return Promise.reject(error);
  }
});

export default axios
```

# 降低全局变量带来的污染

```js
// 使用命名空间
var namespace1 = {
    a: functino() {},
    b: function() {}
}


// 使用闭包封装私有变量
var user = (function() {
    var _name = 'seven',
        _age = 29
        
    return {
        getUserInfo: function() {
            return _name + '-' + _age 
        }
    }
})()
```
