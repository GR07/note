# 设计模式的起源

1995 年，四位前辈出版了一本书《设计模式：可复用面向对象软件的基础》，里面总结了常用的 23 种设计模式，被后人一直沿用至今。


- 创建型模式
    - **单例模式**
    - **原型模式**
    - **工厂模式**
    - 抽象工厂模式
    - 建造者模式
- 结构型模式
    - 适配器模式
    - **装饰器模式**
    - **代理模式**
    - 外观模式
    - 桥接模式
    - 组合模式
    - 享元模式
- 行为型模式
    - 策略模式
    - 模板方法模式
    - **观察者模式**
    - **迭代器模式**
    - 职责连模式
    - 命令模式
    - 备忘录模式
    - 状态模式
    - 访问者模式
    - 中介者模式
    - 解释器模式


## 设计模式是什么

设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。

模式就是各种固定套路，每个套路就是一个模式。

## 为什么要学习设计模式

套用前人经验，减低设计和沟通成本，讨论技术方案的时候，一说什么模式大家都知道，不需要去解释。

越大型的系统越能体现设计的价值，好的设计只会模块混乱，不会导致全局混乱。


## 需求 => 设计 => 开发

尝试着写设计方案，不要觉得会浪费时间，一般一个项目或功能2周左右的开发周期会需要这个东西，即使延期也不会是因为写技术方案的几个小时就延期了，有了技术方案就有了前置思考的过程，比如考虑一些异常情况，再比如评审方案的时候某个梗点恰好别人做过，直接去参考就好了。






# 第二页

# S O L I D 五大设计原则

先有设计原则，然后才有模式。

要知道设计模式的前因后果，是为了解决什么问题，所以讲设计模式之前先说清楚设计原则。




S - Single Responsibility Principle 单一职责原则（重要）
  - 一个程序只做好一件事
  - 如果功能过于复杂就拆分开，每个部分保持独立


O - OpenClosed Principle 开放/封闭原则（重要）
  - 增加需求时，扩展新代码，而非修改已有代码
  - 例如 增加新功能时候拓展一个新的模块去做，再把模块组合起来就可以完成新的功能。而不要去修改原来的模块。
  - 所以 SO 之间是相辅相成，如果模块不够独立也是拓展不了的。
  - 为什么不要去修改，因为修改已有的模块可能会造成新的 bug，这也是我们日常开发时常遇到的痛点。从整个软件开发流程看，减少现有逻辑的更改，也会减少测试的成本。


L - Liskov Substitution Principle 里氏替换原则
  - 子类能覆盖父类
  - 父类能出现的地方子类就能出现


I - Interface Segregation Principle 接口隔离原则
  - 保持接口的单一独立，避免出现“胖接口”。
  - 类似于单一职责原则，这里更关注接口。


D - Dependency Inversion Principle 依赖倒置原则
  - 面向接口编程，依赖于抽象而不依赖于具体
  - 使用方只关注接口而不关注具体类的实现
  


日常开发中 S O 原则的体现较多

## js场景

Promise

单一职责原则：每个 then 中的逻辑只做好一件事

开放封闭原则：如果新增需求，扩展then


## 业务场景

轻应用-面试管理项目代码演示



## 总结

在平时业务开发中，设计模式不一定要用，但要尽量写出符合设计原则的代码。




# 第三页

1995 年还没有前端，前后端也有区别，当时的一些设计模式，并不完全适用于现在，所以这里介绍一些我认为较为贴合前端的几种模式。




# 工厂模式

工厂模式是创建对象的一种方式。不用每次都自身去创建对象，而是通过一个既定的 “工厂” 来生产对象并 return 出去。

更多的时候是一种编程习惯。


## 简单工厂模式 示例

```js
class Dog { // 狗狗 
    constructor(name) { console.log(name) }
}

class Cat { // 小猫
    constructor(name) { console.log(name) }
}

new Dog('Spike')
new Cat('Tom')


// 宠物店（工厂）
class Pet {
    // IProduct 符合依赖倒置原则 
    create(type, name) {
        if (type === 'dog') {
            return new Dog(name)
        }
        if (type === 'cat') {
            return new Cat(name)
        }
        throw new Error('Invalid type')
    }
}


// 使用 购买宠物
const pet = new Pet()
const dog = creator.create('dog', 'dd')
const cat = creator.create('cat', 'mm')
```

## Vue `createElement`

在线编译 https://vue-next-template-explorer.netlify.app/

```html
<div>
  <span>静态文字</span>
  <span :id="hello" class="bar">{{ msg }}</span>
</div>
```

会编译出很多 `_createXxx` JS 代码。这些就是工厂函数，用来创建 vnode 。


## 其思想在业务中体现

```js
// <search-pager :tools="tools[tabKey]"></search-pager>

personnel: [
  {
    formatter: (h, e) => createSwitchBtn(h, e, this, '新', true)
  },
  createTool(this, 'refresh', 'BTo6-by5eTG3'),
  createTool(this, 'export', 'BTo0k0gkyFDn'),
  createTool(this, 'general', 'BTo6-by5eTG3'),
  createTool(this, 'custom', 'BTo6-by5eTG3')
]

// 处理配置逻辑
export const createTool = (vm, type, auth) => {
  return toolsConfig[type](vm, auth)
}

// searchPager 工具配置对象
const toolsConfig = {
  refresh: (vm, auth) => {
    return {
      label: '刷新',
      icon: 'reset',
      auth,
      func: () => vm.$refs[vm.tabKey].$refs.queryTable.loadData()
    }
  },
  general: (vm, auth) => {
    return {
      label: '通用查询',
      icon: 'search',
      auth,
      func: () => vm.$refs[vm.tabKey].$refs.queryTable.showGenericDialog(),
    }
  },
  custom: (vm, auth) => {
    return {
      label: '个性设置',
      icon: 'custom',
      auth,
      func: () => vm.$refs[vm.tabKey].$refs.queryTable.showDragDialog(),
    }
  }
}
```


## 解决什么问题？

- 工厂模式为了解决创建对象的问题

- 用工厂把判断逻辑封装了起来，创建对象的过程可能很复杂，但我们只需要关心创建结果

- 代码复用


5 大设计原则中，最重要的就是：**开放封闭原则**，对扩展开放，对修改封闭

- 可以扩展多个类

- 创建逻辑也可以自由扩展

