# 问题

或多或少遇到以下代码逻辑块，分析下可以用什么设计模式解决

```js
const orderType = 1 // 1: 美妆，2：电器，3：家具
const orderWay = 1 // 1：h5，2：app，3：小程序

if (orderType === 1) {
  if (orderWay === 1) {
    console.log('美妆订单h5')
  } else if (orderWay === 2) {
    console.log('美妆订单app')
  } else if (orderWay === 3) {
    console.log('美妆订单小程序')
  }
} else if (orderType === 2) {
  if (orderWay === 1) {
    console.log('电器订单h5')
  } else if (orderWay === 2) {
    console.log('电器订单app')
  } else if (orderWay === 3) {
    console.log('电器订单小程序')
  }
} else if (orderType === 3) {
  if (orderWay === 1) {
    console.log('家具订单h5')
  } else if (orderWay === 2) {
    console.log('家具订单app')
  } else if (orderWay === 3) {
    console.log('家具订单小程序')
  }
}

```

# 设计模式的应用就在身边

计算属性 return


# 第一部分

# 设计模式的起源

1995 年，四位前辈出版了一本书《设计模式：可复用面向对象软件的基础》，里面总结了常用的 23 种设计模式，被后人一直沿用至今。


- 创建型模式
    - **单例模式**
    - **原型模式**
    - **工厂模式**
    - 抽象工厂模式
    - 建造者模式
- 结构型模式
    - 适配器模式
    - **装饰器模式**
    - **代理模式**
    - 外观模式
    - 桥接模式
    - 组合模式
    - 享元模式
- 行为型模式
    - 策略模式
    - 模板方法模式
    - **观察者模式**
    - **迭代器模式**
    - 职责连模式
    - 命令模式
    - 备忘录模式
    - 状态模式
    - 访问者模式
    - 中介者模式
    - 解释器模式


## 设计模式是什么

设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。

模式就是各种固定套路，每个套路就是一个模式。

## 为什么要学习设计模式

套用前人经验，减低设计和沟通成本，讨论技术方案的时候，一说什么模式大家都知道，不需要去解释。

越大型的系统越能体现设计的价值，好的设计只会模块混乱，不会导致全局混乱。


## 需求 => 设计 => 开发

尝试着写设计方案，不要觉得会浪费时间，一般一个项目或功能2周左右的开发周期会需要这个东西，即使延期也不会是因为写技术方案的几个小时就延期了，有了技术方案就有了前置思考的过程，比如考虑一些异常情况，再比如评审方案的时候某个梗点恰好别人做过，直接去参考就好了。






# 第二部分

# S O L I D 五大设计原则

先有设计原则，然后才有模式。

要知道设计模式的前因后果，是为了解决什么问题，所以讲设计模式之前先说清楚设计原则。




S - Single Responsibility Principle 单一职责原则（重要）
  - 一个程序只做好一件事
  - 如果功能过于复杂就拆分开，每个部分保持独立


O - OpenClosed Principle 开放/封闭原则（重要）
  - 增加需求时，扩展新代码，而非修改已有代码
  - 例如 增加新功能时候拓展一个新的模块去做，再把模块组合起来就可以完成新的功能。而不要去修改原来的模块。
  - 所以 SO 之间是相辅相成，如果模块不够独立也是拓展不了的。
  - 为什么不要去修改，因为修改已有的模块可能会造成新的 bug，这也是我们日常开发时常遇到的痛点。从整个软件开发流程看，减少现有逻辑的更改，也会减少测试的成本。


L - Liskov Substitution Principle 里氏替换原则
  - 子类能覆盖父类
  - 父类能出现的地方子类就能出现


I - Interface Segregation Principle 接口隔离原则
  - 保持接口的单一独立，避免出现“胖接口”。
  - 类似于单一职责原则，这里更关注接口。


D - Dependency Inversion Principle 依赖倒置原则
  - 面向接口编程，依赖于抽象而不依赖于具体
  - 使用方只关注接口而不关注具体类的实现
  


日常开发中 S O 原则的体现较多

## js场景

Promise

单一职责原则：每个 then 中的逻辑只做好一件事

开放封闭原则：如果新增需求，扩展then



## 总结

在平时业务开发中，设计模式不一定要用，但要尽量写出符合设计原则的代码。




# 第三部分

1995 年还没有前端，前后端也有区别，当时的一些设计模式，并不完全适用于现在，所以这里介绍一些我认为较为贴合前端的几种模式。


# 工厂模式

工厂模式是创建对象的一种方式。不用每次都自身去创建对象，而是通过一个既定的 “工厂” 来生产对象并 return 出去。

更多的时候是一种编程习惯。


## 简单工厂模式 示例

```js
class Dog { // 狗狗 
    constructor(name) { console.log(name) }
}

class Cat { // 小猫
    constructor(name) { console.log(name) }
}

new Dog('Spike')
new Cat('Tom')


// 宠物店（工厂）
class Pet {
    // IProduct 符合依赖倒置原则 
    create(type, name) {
        if (type === 'dog') {
            return new Dog(name)
        }
        if (type === 'cat') {
            return new Cat(name)
        }
        throw new Error('Invalid type')
    }
}


// 使用 购买宠物
const pet = new Pet()
const dog = creator.create('dog', 'dd')
const cat = creator.create('cat', 'mm')
```

## Vue `createElement`

在线编译 https://vue-next-template-explorer.netlify.app/

```html
<div>
  <span>静态文字</span>
  <span :id="hello" class="bar">{{ msg }}</span>
</div>
```

会编译出很多 `_createXxx` JS 代码。这些就是工厂函数，用来创建 vnode 。


## 其思想在业务中体现

```js
// <search-pager :tools="tools[tabKey]"></search-pager>

personnel: [
  {
    formatter: (h, e) => createSwitchBtn(h, e, this, '新', true)
  },
  createTool(this, 'refresh', 'BTo6-by5eTG3'),
  createTool(this, 'export', 'BTo0k0gkyFDn'),
  createTool(this, 'general', 'BTo6-by5eTG3'),
  createTool(this, 'custom', 'BTo6-by5eTG3')
]

// 处理配置逻辑
export const createTool = (vm, type, auth) => {
  return toolsConfig[type](vm, auth)
}

// searchPager 工具配置对象
const toolsConfig = {
  refresh: (vm, auth) => {
    return {
      label: '刷新',
      icon: 'reset',
      auth,
      func: () => vm.$refs[vm.tabKey].$refs.queryTable.loadData()
    }
  },
  general: (vm, auth) => {
    return {
      label: '通用查询',
      icon: 'search',
      auth,
      func: () => vm.$refs[vm.tabKey].$refs.queryTable.showGenericDialog(),
    }
  },
  custom: (vm, auth) => {
    return {
      label: '个性设置',
      icon: 'custom',
      auth,
      func: () => vm.$refs[vm.tabKey].$refs.queryTable.showDragDialog(),
    }
  }
}
```


## 解决什么问题？

- 工厂模式为了解决创建对象的问题

- 用工厂把判断逻辑封装了起来，创建对象的过程可能很复杂，但我们只需要关心创建结果

- 代码复用


5 大设计原则中，最重要的就是：**开放封闭原则**，对扩展开放，对修改封闭

- 可以扩展多个类

- 创建逻辑也可以自由扩展





# 策略模式


策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理

## 场景示例

计算年终奖
```ts
function get(type, salary, sales) {
    // 计算typeA年终奖
    if (type === 'typeA') {
      return salary * 0.8 + sales * 0.5
    }
    // 计算typeB年终奖
    if (type === 'typeB') {
      return salary * 1.2 + sales * 0.3
    }
    // 计算typeC年终奖
    if (type === 'typeC') {
      return salary * 2
    }
}
```

单一职责改造
```js
// 计算typeA年终奖
const handleTypeA = (salary, sales) => {
    return salary * 0.8 + sales * 0.5
}
// 计算typeB年终奖
const handleTypeB = (salary, sales) => {
    return salary * 1.2 + sales * 0.3
}
// 计算typeC年终奖
const handleTypeC = (salary, sales) => {
    return salary * 2
}

// 计算年终奖
function get(type, salary, sales) {
    if (type === 'typeA') {
      return handleTypeA(salary, sales)
    }
    if (type === 'typeB') {
      return handleTypeB(salary, sales)
    }
    if (type === 'typeC') {
      return handleTypeC(salary, sales)
    }
}
// 上面虽然实现了每个函数的的功能独立，但是对于功能的扩展依旧束手无策，还是需要在源函数添加if xxx，这样子并没有实现我们对于扩展开放，对于修改封闭的原则
```

开放封闭改造
```js
const typeMap = {
    // 计算typeA年终奖
    typeA(salary, sales) {
      return salary * 0.8 + sales * 0.5
    },
    // 计算typeB年终奖
    typeB(salary, sales) {
      return salary * 1.2 + sales * 0.3
    },
    // 计算typeC年终奖
    typeC(salary, sales) {
      return salary * 2
    }
}

// 计算年终奖
function get(type, salary, sales) {
    return typeMap[type](salary, sales)
}
// 新增一种类型时，只需要对于 typeMap 重新扩展一个类型即可，而不需要修改原函数 get，这样子我们的年终奖计算逻辑不仅消除了大量的 if-else 判断逻辑，还实现了很强的代码复用性，可扩展性，可维护性。
```



## 在业务中体现

轻应用首页列表 item 根据 3 个参数，跳转多个详情页，if else 当然可以实现，但实现后就会像开篇的代码块一样层层嵌套。

```js
const InterviewNostart = () => {
    return 'InterviewNostart'
}
const InterviewAssessment = () => {
    return 'InterviewAssessment'
}
const InterviewResult = () => {
    return 'InterviewResult'
}
const CarNostart = () => {
    return 'CarNostart'
}


// interviewProcess 10，20，30，50，60，70
// status 10，20，30，50
// noStartFlag 1，2
const createMap = new Map([
  [{ interviewProcess: 10, status: 10, noStartFlag: 1 }, InterviewNostart],
  [{ interviewProcess: 10, status: 20, noStartFlag: 2 }, InterviewAssessment],
  [{ interviewProcess: 20, status: 30, noStartFlag: 1 }, InterviewResult],
  [{ interviewProcess: 50, status: 10, noStartFlag: 1 }, CarNostart],
    // ...
])


export function run (data) {

  let toArr = [...createMap]

  let {
    // 面试轮次
    interviewProcess = '',
    // 面试状态
    status = '',
    // 是否开始
    noStartFlag = ''
  } = data

  return toArr.find(([key]) => (key.interviewProcess === +interviewProcess && key.status === +status && key.noStartFlag === +noStartFlag))

}
```

## 解决什么问题？

多重条件语句判断不易维护，使用策略模式可以避免使用多重条件语句，每个分支单独处理，相互隔离。

策略模式提供了对开闭原则的支持，在不修改原代码的情况下，灵活增加新算法。


# 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点；

即不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。


```js
// 非单例
function Singleton() {}
const s1 = new Singleton()
const s2 = new Singleton()

console.log(s1 === s2)
```
## 实现方式

要实现单例模式，需要构造函数具备判断自己是否已经创建过一个实例的能力

目前有三种方式，闭包、Class静态方法、模块化。


- 闭包实现

```js
const Singleton = (function () {
    // 实例变量
    let instance = null;
    // 实例的构造函数
    function getInstance() {}
    return function () {
      // 判断是否已经new过1个实例
      if (!instance) {
        // 如果实例不存在，则先new一个实例
        instance = new getInstance();
      }
      // 未来不管执行多少次，都返回这个唯一实例
      return instance;
    };
})();
const s1 = Singleton()
const s2 = Singleton()

console.log(s1 === s2)
```

- 静态方法实现

```js
// 当前类未被销毁时，静态属性也不会被销毁，具有类似于闭包的缓存作用，可以用来存储实例
class Singleton {
    // 实例变量
    static instance = null;
    // 返回唯一实例的静态方法
    static getInstance() {
      // 判断是否已经new过1个实例
      if (!Singleton.instance) {
        // 如果实例不存在，则先new一个实例
        Singleton.instance = new Singleton();
      }
      // 未来不管执行多少次，都返回这个唯一实例
      return Singleton.instance;
    }
}
const s1 = Singleton.getInstance();
const s2 = Singleton.getInstance();
console.log(s1 === s2);
```

- 模块化

```js
// index.js
// 借助模块化实现单例模式的方式其实本质还是闭包，不过会比较简洁
// 在加载模块时都会对加载的模块用函数包裹
// 实例变量
let instance = null;
// 实例的构造函数
function getInstance() {}
export default () => {
  // 判断是否已经new过1个实例
  if (!instance) {
    // 如果实例不存在，则先new一个实例
    instance = new getInstance();
  }
  // 未来不管执行多少次，都返回这个唯一实例
  return instance;
};
```

对于前端也不是说完全100%都符合原始单例模式的定义，更多的借助于单例模式的思想，来实现我们保持唯一实例或者唯一值。


## 场景

Vuex的源码里，可以看到在store.js这个文件里面声明Vue全局变量

```js
import applyMixin from './mixin'

let Vue // bind on install

export function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if (__DEV__) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}
```

## 解决什么问题？

避免一个全局使用的类频繁地被创建和销毁，占用内存

需要维持全局仅有一个实例，不然会导致出错的场景（vuex）。

以上这就是单例模式的价值。


在前端单例思想随处可见，全局变量、全局api 只要是全局唯一的都符合单例的思想。




# 观察者模式

顾名思义，一直观察着，如果有变化，则做些什么事情。

当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式。


## 场景 - DOM 事件

DOM 事件就是最常用的观察者模式

```html
<button id="btn1">btn</button>

<script>
    const $btn1 = $('#btn1')
    $btn1.click(function () {
        // 点击触发
        console.log(1)
    })
    $btn1.click(function () {
        // 点击触发
        console.log(2)
    })
</script>
```


## 生活案例

手机淘宝买商品，但是商品还没到开售时间，我们可以点发售提醒我，商品发售时会推送给我通知，我们收到通知再去购买。

商品与顾客之间的关系其实就构成了一个观察者模式。


在观察者模式中，只有两种主体：目标对象 (Object) 和 观察者 (Observer)


目标对象 Subject

  - 维护观察者列表 observerList ———— 维护已订阅的顾客的列表

  - 定义添加观察者的方法 ———— 提供顾客的订阅功能

  - 当自身发生变化后，通过调用自己的 notify 方法依次通知每个观察者执行 update 方法 ———— 商品发售开始时通知订阅的顾客


观察者 Observer

  - 需要实现 update 方法，供目标对象调用。update方法中可以执行自定义的业务逻辑 ———— 商品发售可以自行决定去抢购或做别的事情。


## 代码实现

```js

// 商品（主题）
class Subject {

    constructor() {

        this.observerList = []

    }

    addObserver(observer) {

        this.observerList.push(observer)

    }

    notify() {

        console.log(`商品发售了，去通知所有顾客`)

        this.observerList.forEach(observer => observer.update())

    }
}

// 顾客（观察者）
class Observer {

  constructor(name) {

    this.name = name

  }

  update() {
      
    this.know()

    this.turnPhone()

  }

  know() {
    console.log(`你好 ${this.name}，商品已开售！`)
  }

  turnPhone () {
    console.log(`打开手机，考虑下单！`)
  }

}

const subject = new Subject()

const stu1 = new Observer("顾客1")
const stu2 = new Observer("顾客2")

// 顾客1 顾客2 订阅通知
subject.addObserver(stu1);
subject.addObserver(stu2);


// 发售了 去通知所有订阅的顾客
subject.notify();

```

## 总结

观察者模式是前端最常用的一个设计模式之一，也是 界面编程最重要的思想。




# 发布订阅模式

发布订阅模式，没有在传统 23 种设计模式中，它是观察者模式的另一个版本。

实际工作中，不会区分的那么细致。


## 生活案例

追一部剧，用户会去视频平台订阅，等视频平台更新了剧集，视频平台会通知所有的订阅用户，平台又会有多个剧。

```js
class PubSub {
    constructor() {
        // 事件中心
        // 存储格式: 美剧: [], 港剧: []
        // 每种事件(任务)下存放其订阅者的回调函数
        this.events = {}
    }
    // 订阅方法
    subscribe(type, cb) {
        if (!this.events[type]) {
            this.events[type] = [];
        }
        this.events[type].push(cb);
    }
    // 某个剧更新时平台会发布
    publish(type, ...args) {
        if (this.events[type]) {
            this.events[type].forEach(cb => cb(...args))
        }
    }
    // 取消订阅方法
    unsubscribe(type, cb) {
        if (this.events[type]) {
            const cbIndex = this.events[type].findIndex(e=> e === cb)
            if (cbIndex != -1) {
                this.events[type].splice(cbIndex, 1);
            }
        }
        if (this.events[type].length === 0) {
            delete this.events[type];
        }
    }
    unsubscribeAll(type) {
        if (this.events[type]) {
            delete this.events[type];
        }
    }
}

// 创建一个平台
let pubsub = new PubSub()

// 用户A订阅美剧
pubsub.subscribe('美剧', function (taskInfo){
    console.log(`我是用户A ${taskInfo}`)
})
// 用户A订阅港剧
pubsub.subscribe('港剧', function (taskInfo){
    console.log(`我是用户A ${taskInfo}`)
})
// 用户B订阅美剧
pubsub.subscribe('美剧', function (taskInfo) {
    console.log(`我是用户B ${taskInfo}`)
})

// 发布战斗任务
pubsub.publish('userA', "篮球")

```

我们可以发现发布者和订阅者不知道对方的存在。需要中介去帮你找，将订阅者和发布者串联起来，利用中介过滤和分配所有输入的消息。







# 最后总结

设计模式可能不常用，但它们的开发思想和编码套路 给实际开发提供了指导意义。

平时开发时尽量拆出小的模块，也会提高模块复用的可能性，产生杠杆效应后，后面会发现前面花时间做的拆分都是值得的。

本次内容后，希望对大家平时的编码编写维护有所帮助，写出符合设计理念的代码。