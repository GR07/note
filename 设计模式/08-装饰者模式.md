# 装饰者模式

动态地给某个对象添加一些额外的职责，是一种实现继承的替代方案。

在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会改变从原有类中派生的对象

仅仅包装现有的模块，使之 “更加华丽” ，并不会影响原有接口的功能 —— 好比你给手机添加一个外壳罢了，并不影响手机原有的通话、充电等功能。

水可以直接喝，但是加上其他果汁会更好喝。

手机贴不贴膜都能用，但是加个手机壳可以防摔。

```js
class Cellphone {
    create() {
        console.log('生成一个手机')
    }
}
class Decorator {
    constructor(cellphone) {
        this.cellphone = cellphone
    }
    create() {
        this.cellphone.create()
        this.createShell(cellphone)
    }
    createShell() {
        console.log('生成手机壳')
    }
}
// 测试代码
let cellphone = new Cellphone()
cellphone.create()

console.log('------------')
let dec = new Decorator(cellphone)
dec.create()
```


# 优点

- 装饰类和被装饰类都只关心自身的核心业务，实现解耦。

- 方便动态的扩展功能，且提供了比继承更多的灵活性。


# 缺点

- 多层装饰比较复杂。

- 常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来




# 场景例子

比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单独的类。
现在要给每种自行车都装上前灯、尾灯和铃铛这3 种配件。
如果使用继承的方式来给每种自行车创建子类，则需要 4×3 = 12 个子类。
但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3 个类

ES7 Decorator 阮一峰



```js
class Man{
  constructor(def = 2,atk = 3,hp = 3){
    this.init(def,atk,hp);
  }

  init(def,atk,hp){
    this.def = def; // 防御值
    this.atk = atk;  // 攻击力
    this.hp = hp;  // 血量
  }
  toString(){
    return `防御力:${this.def},攻击力:${this.atk},血量:${this.hp}`;
  }
}

var tony = new Man();

console.log(`当前状态 ===> ${tony}`); 

// 输出：当前状态 ===> 防御力:2,攻击力:3,血量:3
```