

# 单例模式



- 即对一个 class 只能创建一个实例，即便调用多次，全局保证只有一个实例。

- 创建之后缓存起来以后继续使用


以上这就是单例模式的价值。




# 示例

项目种引入了一个 Class，需要实例化后使用，如果每个页面都 new 一次，浪费内存。

```ts
class SDK {}

const s1 = new SDK()
const s2 = new SDK()
const s3 = new SDK()
```

Vuex 全局数据存储，全局只能有一个实例，如果有多个，数据之间流转会存在问题。

```ts
class Store {}

const s1 = new Store()
const s2 = new Store()
const s3 = new Store()
```



# 演示代码 - TS特性实现

避免重复实例化

```js
class Singleton {
    // private - 设置后外部无法实例化
    private constructor() { }

    // static - 设置后只能通过类访问
    private static instance: Singleton | null

    static getInstance(): Singleton {
        // 这里也可使用 this （static内部this=class 不是实例this）
        if (Singleton.instance == null) {
            Singleton.instance = new Singleton()
        }
        return Singleton.instance
    }
}

// const s1 = new Singleton() // 直接初始化会报错
// Singleton.instance // 直接访问 instance 也会报错

// 创建实例
const s1 = Singleton.getInstance()
const s2 = Singleton.getInstance()

console.log(s1 === s2) // true
```

# 演示代码 - JS实现

避免重复实例化

```js
function genGetInstance() {
    let instance // 闭包

    class Singleton {}

    return () => {
        if (instance == null) {
            instance = new Singleton()
        }
        return instance
    }
}

const getInstance = genGetInstance()

const s1 = getInstance()
const s2 = getInstance()
```

结合模块化

```js
// xxx.js
let instance

class Singleton {}

// 外部只能 import 这个函数
export default () => {
    if (instance == null) {
        instance = new Singleton()
    }
    return instance
}
```

# 是否符合设计原则？

- 通过内部封装，内聚，解耦

- 但不能其他模式一样拆分

总体不违背设计原则


# 总结

前端单例模式并不常用，常用的是单例的思想。

EventBus、Vuex 全局只有一个实例对象。

全局变量、全局api 只要是全局唯一的 都符合单例的思想。







# 单例模式的定义

确保一个类只有一个实例，并提供全局访问


# 用途

主要用途是避免重复的创建实例，节约不必要的开销。

也会用在一些数据缓存、全局通用弹窗（如登录弹窗）等一些场景中








# 单例模式应用于 axios 取消重复请求

- 如果接口返回较慢并且此时用户频繁切换tab，就会导致多个接口一直在响应中，但前面的筛选数据已经没有意义了


```js
import axios from "axios";
const CancelToken = axios.CancelToken;
let cancelId = 0;
let cancelArray = [];

// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // 在请求时，可以添加自己的特点标识去筛选出需要重复取消的接口
  const source = CancelToken.source();
  cancelId++;
  const id = cancelId;
  config.cancelId = id;
  config.cancelToken = source.token;
  const cancelIndex = cancelArray.findIndex(e => e.url === config.url);
  cancelArray.push({
    id,
    url: config.url,
    source
  })
  if (cancelIndex > -1) {
    cancelArray[cancelIndex].source.cancel('取消重复请求');
    cancelArray.splice(cancelIndex, 1)
  }
  return config;
}, function (error) {
  return Promise.reject(error);
});

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
  const cancelIndex = cancelArray.findIndex(e => e.id === response.cancelId);
  if (cancelIndex >= -1) {
    cancelArray.splice(cancelIndex, 1)
  }

  // 对响应数据做点什么
  return response;
}, function (error) {
  if (axios.isCancel(error)) {
    // 如果是取消的接口，可以自行返回一个特定标识
    console.log('isCancel')
  } else {
    // 对响应错误做点什么
    return Promise.reject(error);
  }
});

export default axios
```
