

# 单例模式

前端单例模式并不常用，常用的是单例的思想。

- 即对一个 class 只能创建一个实例，即便调用多次，全局保证只有一个实例。

- 创建之后缓存起来以后继续使用


以上这就是单例模式的价值。




# 示例

项目种引入了一个第三方sdk，需要实例化后使用，如果每个页面都 new 一次，浪费内存。

```ts
class SDK {}

const s1 = new SDK()
const s2 = new SDK()
const s3 = new SDK()
```

Vuex 全局数据存储，全局只能有一个实例，如果有多个，数据之间流转会存在问题。

```ts
class Store {}

const s1 = new Store()
const s2 = new Store()
const s3 = new Store()
```



# 演示代码

```js
class Singleton {
    // private - 外部无法初始化
    private constructor() { }

    // static 属性
    private static instance: Singleton | null

    // static 方法
    static getInstance(): Singleton {
        // 这里也可以写 `this.instance` ，注意和实例方法中 this 的区别！！！
        if (Singleton.instance == null) {
            Singleton.instance = new Singleton()
        }
        return Singleton.instance
    }
}

// const s1 = new Singleton() // 直接初始化会报错
// Singleton.instance // 直接访问 instance 也会报错

// 创建实例
const s1 = Singleton.getInstance()
const s2 = Singleton.getInstance()

console.log(s1 === s2) // true
```



# 单例模式的定义

确保一个类只有一个实例，并提供全局访问


# 用途

主要用途是避免重复的创建实例，节约不必要的开销。

也会用在一些数据缓存、全局通用弹窗（如登录弹窗）等一些场景中



# 标准的单例模式

```js
let instance
function Alert (content) {

  // 只有没有 instance 时才会执行初始化方法

  // 后面再new的时候会直接复用之前的 instance

  // 这就保证了即使new很多次，也能保证只实例化了一次，始终都是同一个实例。

  if (!instance) {
    instance = this
  }
  instance.init(content)
  return instance
}
Alert.prototype.init = function (content) {
  this.content = content
}

let a = new Alert('a')
a.content // a
let b = new Alert('b')
b.content // b
// 也是 b，访问的是同一个实例，只不过 new Alert('b') 时候内部并没有new过程，只是改变了content属性
a.content // b

console.log(a === b) // true
```


# 使用ES5闭包优化单例

```js
// 自执行函数包裹
let Alert = (function () {

  let instance

  function Alert (content) {
    if (!instance) {
      instance = this
    }
    instance.init(content)

    return instance
  }
  Alert.prototype.init = function (content) {
    this.content = content
  }

  return Alert

})()
```


# 兼容 new Alert() 或者 Alert()

```js
let Alert = (function () {

  let instance

  function Alert (content) {
    
    if (this instanceof Alert) {
      // 场景：new Alert()
      if (!instance) {
        instance = this
      }
    } else {
      // 场景：Alert()
      if (!instance) {
        instance = new Alert(content)
      }
    }
    
    instance.init(content)

    return instance
  }
  Alert.prototype.init = function (content) {
    this.content = content
  }

  return Alert

})()

let a = Alert('a') // 支持 类似 Array()
let b = new Alert('b') // 支持 类似 new Array()

a === b // true
```


# 利用 || 运算符 精简上述代码

```js
let Alert = (function () {

  let instance

  function Alert (content) {
    
    // 判断当前的this对象 是否是 构造函数的实例对象
    if (this instanceof Alert) {
      // 是的话赋值this
      instance = instance || this

    } else {
      // 不是则 new
      instance = instance || new Alert(content)

    }
    
    instance.init(content)

    return instance
  }
  Alert.prototype.init = function (content) {
    this.content = content
  }

  return Alert

})()
```

# 再次精简

```js
let Alert = (function () {

  let instance

  function Alert (content) {
    // 原理：因为 new Alert 就是再走一遍 (this instanceof Alert)
    // 判断当前的this对象 是否是 构造函数的实例对象，是的话赋值this
    instance = instance || (this instanceof Alert ? this : new Alert(content))
    
    instance.init(content)

    return instance
  }
  Alert.prototype.init = function (content) {
    this.content = content
  }

  return Alert

})()
```



# 惰性单例

- 案例：创建dom元素

只有在第一次 new Alert 时，才会去创建 dom 节点，再次执行也不会创建多余的节点。

```js
let Alert = (function () {

  let instance
  let dom

  function creatDom () {
    if (!dom) {
      dom = document.createElement('div')
      dom.style.display = 'none'
      document.body.append(dom)
    }
  }

  function Alert (content) {
    
    instance = instance || (this instanceof Alert ? this : new Alert(content))
    
    instance.init(content)

    return instance
  }
  // 初始化
  Alert.prototype.init = function (content) {
    creatDom()
    dom.innerHTML = content
    dom.style.display = 'block'
  }
  // 隐藏
  Alert.prototype.hide = function () {
    dom.style.display = 'none'
  }

  return Alert

})()
```


# 惰性单例 单一职责优化

- 设计模式中的单一职责概念：一个函数只有一个职责，如果想做别的事，只能用函数组合的方式实现功能。

```js
// 只负责创建dom
function creatDom () {
  let dom = document.createElement('div')
  dom.style.display = 'none'
  document.body.append(dom)
  return dom
}

/** 
 * Single
 * 给 creatDom 创建一个单例模式
 * 可以当作一个方法执行 Single()
 * 也可以作为构造函数执行 new Single()
 */
let Single = (function () {
  let instance
  return function (fn) {
    // 如果 instance 存在，直接返回
    // 否则 调用 creatDom 创建返回一个 dom
    return instance || (instance = fn.apply(this, arguments))
  }
})()

let Alert = (function () {

  let instance
  let dom

  function Alert (content) {

    instance = instance || (this instanceof Alert ? this : new Alert(content))
    
    instance.init(content)

    return instance
  }
  // 初始化
  Alert.prototype.init = function (content) {
    // 每次都重新赋值
    dom = new Single(creatDom)
    dom = Single(creatDom)
    // 以上两种方式 都是返回 <div style="display: block;">guorrr</div>
    dom.innerHTML = content
    dom.style.display = 'block'
  }
  // 隐藏
  Alert.prototype.hide = function () {
    dom.style.display = 'none'
  }

  return Alert

})()
```



# 简洁版 - 惰性单例

```js
var createLoginLayer = (function() {
    var div;
    return function() {
        if(!div) {
            div = document.createElement('div');
            div.innerHtml = '登录弹窗';
            div.style.display = 'none';
            document.body.appendChild(div);
        }
        return div;
    }
})()

document.getElementById('loginBtn').onclick = function() {
    var loginLayer = createLoginLayer();
    loginLayer.style.display = 'block';
}
```


# 简洁版 - 惰性单例 单一职责优化


```js
// 我们将创建登录弹窗和单例的逻辑分离成 createLoginLayer 和 getSingle，这样之后再有了类似的需求，就可以复用到 getSingle 方法实现单例。

// 通用的惰性单例
var getSingle = function(fn) {
    var result;
    return function() {
        return result || (resule = fn.apply(this, arguments));
    }
}

// 创建登录弹窗的方法就可以改写成
var createLoginLayer = function() {
    var div = document.createElement('div');
    div.innerHtml = '登录弹窗';
    div.style.display = 'none';
    document.body.appendChild(div);
    return div;
}

var createSingleLoginLayer = getSingle(createLoginLayer);

document.getElementById('loginBtn').onclick = function() {
    var loginLayer = createSingleLoginLayer();
    loginLayer.style.display = 'block';
}
```




# 单例模式应用于 axios 取消重复请求

- 如果接口返回较慢并且此时用户频繁切换tab，就会导致多个接口一直在响应中，但前面的筛选数据已经没有意义了


```js
import axios from "axios";
const CancelToken = axios.CancelToken;
let cancelId = 0;
let cancelArray = [];

// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // 在请求时，可以添加自己的特点标识去筛选出需要重复取消的接口
  const source = CancelToken.source();
  cancelId++;
  const id = cancelId;
  config.cancelId = id;
  config.cancelToken = source.token;
  const cancelIndex = cancelArray.findIndex(e => e.url === config.url);
  cancelArray.push({
    id,
    url: config.url,
    source
  })
  if (cancelIndex > -1) {
    cancelArray[cancelIndex].source.cancel('取消重复请求');
    cancelArray.splice(cancelIndex, 1)
  }
  return config;
}, function (error) {
  return Promise.reject(error);
});

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
  const cancelIndex = cancelArray.findIndex(e => e.id === response.cancelId);
  if (cancelIndex >= -1) {
    cancelArray.splice(cancelIndex, 1)
  }

  // 对响应数据做点什么
  return response;
}, function (error) {
  if (axios.isCancel(error)) {
    // 如果是取消的接口，可以自行返回一个特定标识
    console.log('isCancel')
  } else {
    // 对响应错误做点什么
    return Promise.reject(error);
  }
});

export default axios
```

# 降低全局变量带来的污染

```js
// 使用命名空间
var namespace1 = {
    a: functino() {},
    b: function() {}
}


// 使用闭包封装私有变量
var user = (function() {
    var _name = 'seven',
        _age = 29
        
    return {
        getUserInfo: function() {
            return _name + '-' + _age 
        }
    }
})()
```
