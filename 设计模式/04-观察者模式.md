# 观察者模式

观察者模式是前端最常用的一个设计模式，也是 界面编程最重要的思想。

由此引出了发布订阅模式（不在23种设计模式之中）

# 观察者模式

顾名思义，一直观察着，如果有变化，则做些什么事情。

例如：去买咖啡，去了店里下单后，咖啡好了会叫号或者送过去，不需要我们自己不断去问店员做好了没。

DOM 事件就是最常用的观察者模式

```html
<button id="btn1">btn</button>

<script>
    const $btn1 = $('#btn1')
    $btn1.click(function () {
        // 点击触发
        console.log(1)
    })
    $btn1.click(function () {
        // 点击触发
        console.log(2)
    })
    $btn1.click(function () {
        // 点击触发
        console.log(3)
    })
</script>
```

Vue 的生命周期，也是观察者模式。



# 基础演示代码

一个主题 和 n个观察者 是**一对多**的关系

```ts
// 主题
class Subject {

    // 状态
    private state: number = 0

    // 所有买咖啡的人
    private observers: Observer[] = []
    
    // 获取当前 state 状态
    getState(): number {
        return this.state
    }

    // 更新 state 状态
    setState(newState: number) {
        this.state = newState
        // 状态更新时 去通知观察者
        this.notify()
    }

    // 添加一个观察者
    attach(observer: Observer) {
        this.observers.push(observer)
    }

    // 通知所有观察者
    private notify() {
        // 遍历
        for (const observer of this.observers) {
            observer.update(this.state)
        }
    }
}

// 观察者
class Observer {
    name: string
    constructor(name: string) {
        this.name = name
    }
    // 取咖啡
    update(state: number) {
        console.log(`${this.name} 取咖啡, 状态 ${state}`)
    }
}

// 主题
const sub = new Subject()

// 观察者A
const observer1 = new Observer('A')
// 添加A
sub.attach(observer1)

// 观察者B
const observer2 = new Observer('B')
// 添加B
sub.attach(observer2)

// 更新状态 触发所有观察者的 update
sub.setState(1)
```

# 是否符合设计原则？

5 大设计原则中，最重要的就是：**开放封闭原则**，对扩展开放，对修改封闭

- Subject 和 Observer 分离，解耦
- Subject 可自由扩展
- Observer 可自由扩展
- 高内聚 低耦合








你不会观察者模式，你还配做前端吗？

# 观察者模式

观察者模式包含发布订阅模式

vue 就是 观察者模式，观察数据，数据发生变化时，通知所有观察者，更新视图

## 观察者模式

+ 观察者

+ 被观察者

+ 被观察者里面存放一个数组 -- [观察者实例对象]

```js
// 被观察者
function BeLook() {
    this.state = '状态好';
    this.arr = []; // 存放观察者的数组
}

BeLook.prototype.add = function (look) {
    this.arr.push(look)
}

BeLook.prototype.setState = function (newState) {
    this.state = newState;
    this.arr.forEach(c => c.update(newState))
}

// 观察者
function Look(who) {
    this.name = who;
}

Look.prototype.update = function (state) {
    console.log(`${this.name}-----当前${state}`);
}


const look1 = new Look('1号观察者')
const look2 = new Look('2号观察者')

const be = new BeLook()

be.add(look1)
be.add(look2)


be.setState('状态差！')
be.setState('状态差！123')
```