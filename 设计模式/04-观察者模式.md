# 观察者模式

观察者模式是前端最常用的一个设计模式，也是 界面编程最重要的思想。

由此引出了发布订阅模式（不在23种设计模式之中）

# 观察者模式

顾名思义，一直观察着，如果有变化，则做些什么事情。

例如：去买咖啡，去了店里下单后，咖啡好了会叫号或者送过去，不需要我们自己不断去问店员做好了没。




# 基础演示代码

一个主题 和 n个观察者 是**一对多**的关系

```ts
// 主题
class Subject {

    // 状态
    private state: number = 0

    // 所有买咖啡的人
    private observers: Observer[] = []
    
    // 获取当前 state 状态
    getState(): number {
        return this.state
    }

    // 更新 state 状态
    setState(newState: number) {
        this.state = newState
        // 状态更新时 去通知观察者
        this.notify()
    }

    // 添加一个观察者
    attach(observer: Observer) {
        this.observers.push(observer)
    }

    // 通知所有观察者
    private notify() {
        // 遍历
        for (const observer of this.observers) {
            observer.update(this.state)
        }
    }
}

// 观察者
class Observer {
    name: string
    constructor(name: string) {
        this.name = name
    }
    // 取咖啡
    update(state: number) {
        console.log(`${this.name} 取咖啡, 状态 ${state}`)
    }
}

// 主题
const sub = new Subject()

// 观察者A
const observer1 = new Observer('A')
// 添加A
sub.attach(observer1)

// 观察者B
const observer2 = new Observer('B')
// 添加B
sub.attach(observer2)

// 更新状态 触发所有观察者的 update
sub.setState(1)
```

# 是否符合设计原则？

5 大设计原则中，最重要的就是：**开放封闭原则**，对扩展开放，对修改封闭

- Subject 和 Observer 分离，解耦
- Subject 可自由扩展
- Observer 可自由扩展
- 高内聚 低耦合


# 场景-DOM 事件

DOM 事件就是最常用的观察者模式

```html
<button id="btn1">btn</button>

<script>
    const $btn1 = $('#btn1')
    $btn1.click(function () {
        // 点击触发
        console.log(1)
    })
    $btn1.click(function () {
        // 点击触发
        console.log(2)
    })
</script>
```

# 场景-Vue 的生命周期

只需要注册你的函数即可，组件到了相应的生命周期会去执行。

# 场景-Vue watch

```js
// Vue 组件配置
{
    data() {
        name: 'xx'
    },
    watch: {
        name(newVal, val) {
            console.log(newValue, val)
        }
    }
}
```

# 场景-各种异步回调函数

- setTimeout setInterval

- Promise then 回调

- MutationObserver

```ts
function callback(records: MutationRecord[], observer: MutationObserver) {
    for (let record of records) {
        console.log('record', record)
    }
}
const observer = new MutationObserver(callback)

const containerElem = document.getElementById('container')
const options = {
    attributes: true, // 监听属性变化
    attributeOldValue: true, // 变化之后，记录旧属性值
    childList: true, // 监听子节点变化（新增删除）
    characterData: true, // 监听节点内容或文本变化
    characterDataOldValue: true, // 变化之后，记录旧内容
    subtree: true, // 递归监听所有下级节点
}

// 开始监听
observer.observe(containerElem, options)

// 停止监听
// observer.disconnect()
```
