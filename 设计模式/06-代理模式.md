# 代理模式定义

代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。



# 为什么要使用代理模式

中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。


# 例一

宠物店也算是一种中介代理，因为所有的宠物来源都来不会直接在商店产生，他们有的来自于野外，有的来自于养殖场等。

```js
class headPet { // 宠物总店提供了最基础的出售，回购宠物的服务
  sellPet(name) { // 出售宠物
    console.log('出售一只宠物', name)
  }
  desert(name) { // 遗弃宠物
    console.log('遗弃一只宠物', name)
  }
}

class subPet extends headPet { // 宠物分店，我们提供搭配服务，以便更好地卖宠物
  constructor() {
    super()
  }
  sell(name) { // 出售宠物
    this.sellPet(name)
  }
  sellPetFood(name) { // 购买宠物食物送宠物活动
    console.log('搭配了一大波食粮')
    this.sellPet(name)
  }
  sellPetCage(name) { // 购买宠物笼子送宠物活动
    console.log('搭配一个大笼子')
    this.sellPet(name)
  }
}

const subPet1 = new subPet()
subPet1.sell('tom')
subPet1.sellPetFood('tom')
subPet1.sellPetCage('tom')
```


# 例二

- 代理请求-读取本地缓存

我们代理了一层 ajax 请求方法，加入了一道 cache 层，这样可以帮助我们在相同参数的请求情况下，不去调用 http 请求，节约部分请求时间跟资源。

```js
function ajax(params) { // 实际发送请求方法
  console.log(`发送请求${params}`)
  return params + Math.random()
}

const storage = new Map();

function cache(params) { // 缓存模式
  if (storage.has(params)) {
    return storage.get(params)
  }
  const value = ajax(params)
  storage.set(params, value)
  return value
}

function proxyAjax(params) { // 代理ajax请求
  return cache(params)
}

console.log(proxyAjax(1)) // 发送参数为1的请求
console.log(proxyAjax(1)) // 发送相同参数为1的请求，cache读取到缓存，所以不再调用ajax方法，直接返回结果
console.log(proxyAjax(2)) // 发送参数为2的请求，此时未读取到缓存，直接调用ajax方法，从后台请求
```

# 例三

- 缓存代理-处理缓存时间

```js
class Storage {

  constructor(props) { // 根据类型跟缓存时间，初始化缓存方法
    const { type, time } = props
    this.type = type
    this.time = time
    this.storageType = {
      local: 'localStorage',
      session: 'sessionStorage'
    }
  }

  setItem(key, value) { // 代理原生缓存方法，添加缓存时间
    window[this.storageType[this.type]].setItem(key, JSON.stringify({
      value,
      time: new Date().getTime()
    }));
  }

  getItem(key) { // 代理原生获取缓存方法，根据缓存时间，判断数据是否过期
    try {
      const { time, value } = JSON.parse(window[this.storageType[this.type]].getItem(key));
      const now = new Date().getTime()
      if (now > time + this.time) {
        window[this.storageType[this.type]].removeItem(key);
        return null
      } else {
        return value
      }
    } catch (e) {
      return null
    }
  }
}

const local = new Storage({ type: 'local', time: 30000 }) // 初始化localStorage,添加5分钟缓存时效
const session = new Storage({ type: 'session', time: 30000 }) // 初始化sessionStorage,添加5分钟缓存时效
local.setItem(1, 2)
local.getItem(1)
session.setItem(3, 4)
session.getItem(3)

```