#### 什么算是垃圾数据

在一些数据不被需要的时候，它就是垃圾数据，垃圾数据占用的内存就应该被回收。

例子：
```js
// 创建了一个对象obj在堆内存中
const obj = new Object()
// 给这个对象增加一个属性并赋值，在堆内存中多了[1, 2]
obj.a = [1, 2]
// 然后又把a赋值为对象，在堆内存中多了{'key': 123}
obj.a = {'key': 123}
```
上面代码，a 的指向改变后此时存在堆内存中的[1, 2]最后就变成了垃圾数据




# 内存分两大区域 栈空间 和 堆空间


# 栈

栈空间其实就是 JavaScript 中的函数调用栈，是用来储存执行上下文，以及存储执行上下文中的一些基本类型中的小数据。（存变量声明、函数声明这些）

- 变量环境： 存放var声明与函数声明的变量空间，编译时就能确定，不受块级作用域影响

- 词法环境： 存放let与const声明的变量空间，编译时不能完全确定，受块级作用域影响


# 堆

堆空间，则是用来储存大数据如引用类型，然后把他们的引用地址保存到栈空间的变量中，所以多了这一道中转，JavaScript 对堆空间数据的读取自然会比栈空间数据的要慢。





# 回收方式




# 栈内存回收

简单说，只要函数调用结束，该栈内存就会自动被回收，不需要我们操心。

当一个函数调用完毕，JS 会把ESP指针移至下一个函数，这个指针下移的操作就是销毁函数执行上下文的过程。最后销毁后的执行上下文所占用的区域会变成无效区域，下一个函数执行上下文压入调用栈的时候会直接覆盖其内存空间。


# 堆内存回收

- JS 把堆空间分成 新生代 和 老生代 两个区域，分别对应两种回收器（副垃圾回收器 / 主垃圾回收器）

- 新生代中存放的是生存时间短的对象，通常只支持 1～8M 的容量；

- 老生代中存放的生存时间长的对象，一些大的数据也会被直接分配到老生区中。


- 垃圾回收一般都有相同的执行流程

1. 标记空间中活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 内存整理，这步是可选的，因为有的垃圾回收器工作过程会产生内存碎片，这时就需要内存整理防止不够连续空间分配给大数据



# 副垃圾回收器

它把新生区划分为两个区域：对象区域 和 空闲区域

新加入的对象都会存放到对象区域，当对象区域快被写满时，会对对象区域进行垃圾标记，把存活对象复制并有序排列至 空闲区域，完成后让这两个区域角色互转，由此便能无限循环进行垃圾回收。

注：这里的回收存在晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。



# 主垃圾回收器

由于老生区空间大，数据大，主要是采用 标记-整理 算法，可以将整个过程想象成从根溢出一个巨大的油漆桶，从一个根节点出发将可到达的对象标记染色， 然后移除未标记的。


## 具体步骤：

1. 标记可达值

从根节点出发遍历所有对象，可以遍历到的对象是可达值，没有遍历到的是不可达值。

浏览器环境的根节点：全局变量 window、DOM 树、存放在栈上的变量。（这些根节点会被遍历。）


2. 回收不可达值所占据的内存

在所有的可达值标记完成之后，统一清理内存中所有不可达的对象。


3. 做内存整理

频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫「内存碎片」。

所以最后一步是整理内存碎片，防止不够连续空间分配给大数据。（有的垃圾回收器不会产生内存碎片，比如副垃圾回收器）




# 垃圾回收的时机

因为垃圾回收工作是需要占用主线程的，必须暂停 JS 脚本执行等待垃圾回收完成后再继续执行。

所以什么时候垃圾回收，才可以避免长时间暂停JavaScript脚本。


## 三个策略 （分带收集 / 增量收集 / 闲时收集）


- 分带收集

多回收新生代，少回收老生代。这样是为了减少每次需遍历的对象（根节点出发），从而减少每次垃圾回收的耗时。


- 增量收集

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停，所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理，这样就解决了长时间停顿的问题。


- 闲时收集

垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。




# 浏览器中 值类型、引用类型 的内存都是何时释放

引用类型：在没有引用之后，通过 V8 自动回收。

值类型：闭包的情况下，等没有引用才会被 V8 回收。非闭包的情况，等待新生代的对象区和空闲区进行对调时回收。



# 哪些情况会导致内存泄露

内存泄露是指你「用不到」（不可达）的变量，依然占居着内存空间，内存空间不能被再次利用起来。


# 2021.4.24补充：

已不再使用，并且仍然占据内存不能被自动或手动回收，这是一种内存的浪费，叫内存泄漏。

Vue 中内存泄漏：
    console.log() 系列 会一直引用着变量
    监听在 window/body 等事件没有解绑
    绑在 EventBus 的事件没有解绑
    Vuex 的 $store，watch 了之后没有 unwatch
    使用第三方库创建，没有调用正确的销毁函数

解决办法：beforeDestroy 中及时销毁
    绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener。
    观察者模式 $on，$off处理。
    如果组件中使用了定时器，应销毁处理。
    如果在 mounted/created 钩子中使用了第三方库初始化，对应的销毁。
    使用弱引用 weakMap、weakSet。



# 闭包会导致内存泄露吗

闭包里面的变量就是我们需要的变量，不能说是内存泄露。

这个误解是因为 IE bug，在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。



# weakSet 和 Map Set

ES6 新增了两个数据结构 WeakMap、WeakSet，就是为了解决内存泄漏的问题。

它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。