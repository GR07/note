<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>浏览器缓存机制</title>
  <style>

  /*参考掘金地址：https://juejin.im/post/5bf3c28ee51d4514df5b7625*/


  /*web缓存分为很多种，数据库缓存、代理服务器缓存、CDN缓存、浏览器缓存。*/


  /*对http请求来说，客户端缓存分三类：

  不发任何请求，直接从缓存中取数据，代表的特性有： Expires ，Cache-Control=<number！=0>和appcache
  发请求确认是否新鲜，再决定是否返回304并从缓存中取数据 :代表的特性有：Last-Modified/If-Modified-Since，Etag/If-None-Match
  直接发送请求， 没有缓存，代表的特性有：Cache-Control：max-age=0/no-cache*/


  /*Http请求资源缓存*/

  /*页面的缓存状态都是由header决定的，header的参数有四种*/

  /*一、 Cache-Control：
       max-age ：设置缓存有效时间，一定时间内都会使用这个版本的资源，即使服务器上的资源发生了变化，浏览器也不会得到通知。（用于普通缓存）

       s-maxage：同max-age，只用于共享缓存（比如CDN缓存）即使更新了CDN的内容，浏览器也不会进行请求。（用于代理缓存），如果存在s-maxage，则会覆盖掉max-age      

       public：指定响应会被缓存，并且在多用户间共享。

       private：单用户私有的缓存。

       no-cache：指定不缓存响应，表明资源不进行缓存。但是不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改，还要加上private指令，将过期时间设为过去的时间。

       no-store：绝对禁止缓存。

       must-revalidate：指定如果页面是过期的，则去服务器进行获取。这个指令并不常用。
      
      例子：比如我们要请求一个main.js，客户端第一次去请求的时候，大概花了1s钟的时间，
      然后服务器接受到请求之后，通过 将Cache-Control: 30 （默认单位为s），
      传回给浏览器，那么在30s内，我们再刷新页面时，浏览器就会阻隔请求，
      会直接从缓存中读取这个js,过了30s之后才会去重新发起请求。


  二、 Expires：

       如果设置了Cache-Control,那么exipres就失效了,(Expires表示的是本地时间)

       注意：以前设置缓存用 Expires 现在用 Cache-Control



  三、 Last-modified

       上一次的修改时间 Last-Modified: Thu, 26 Jul 2018 09:10:00 GMT，

       需要和cache-control共同使用。

       是检查服务器端资源是否更新的一种方式。


  四、 ETag

       由服务端生成一段MD5值，浏览器会将MD5传回服务器，验证MD5是否一致，一致返回状态码304+空响应。*/
  

  /*Etag与Cache-Control的区别

  Cache-Control是缓存了之后，在缓存时间之内就不再请求，
  然而Etag是请求了之后，发现MD5一样，就返回一个'if-none-match=MD5(string)'这个响应头，如果存在这个，就直接不下载内容（比如js或者css等）
  Cache-Control要更优，因为它直接就不请求了*/




  /*另外的缓存方式：LocalStorage和sessionStorage


  LocalStorage是以页面域名划分的。PC上的兼容性不好，而且当网络速度快，协商缓存响应快时使用localStorage的速度比不上304。不能缓存css文件。

  SessionStorage的数据只存储到特定的会话中，不属于持久化的存储，所以关闭浏览器会清除数据。*/



  
  /*缓存判断流程*/

  /*如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从本地缓存读取，否则才从服务器返回最新的资源。*/



  /*Cache-Control 强缓存*/

  /*优点：
  Cache-Control描述的是一个相对时间，所以缓存管理更有效，安全一些*/
  /*
  1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header。


  2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来


  3.浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。


  4.如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。
  */

  
  /*协商缓存*/
  /*
  1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。


  2.浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。


  3.服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变。



  4.浏览器收到304的响应后，就会从缓存中加载资源。


  5.如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。


    不能缓存的请求：
　　当然并不是所有请求都能被缓存，无法被浏览器缓存的请求如下：

　　　　1. HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求

　　　　2. 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的

　　　　3. 经过HTTPS安全加密的请求

　　　　4. POST请求无法被缓存

　　　　5. HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存

  */


  </style>



</head>
<body>
  
</body>
</html>