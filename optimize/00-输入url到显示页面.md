
# 五个阶段

DNS解析 / TCP连接 / 发送HTTP请求 / 响应HTTP报文 / 拿到结果解析页面



# DNS解析

因为 TCP 是基于 IP 地址的，所以网络通讯只能识别 IP ，那么 DNS 就是一台存储 域名: IP 键值对 的服务器。

## 流程

dns 客户端 向 dns 服务器 发送查询请求，找到 ip 后返回给浏览器，建立 TCP 连接，发 http 包。

## dns 查找过程

1. 查找浏览器的缓存

2. 查找 Hosts 文件

3. 查找路由器的缓存

4. 查找运营商的 dns 缓存服务器

5. 查找根域名服务器

6. 查找顶级域名服务器

7. 查找主域名服务器

最终找到后，缓存以备下一次使用，同时将该结果反馈给客户端，客户端通过这个 IP 地址与 web 服务器建立链接。




# TCP连接

建立一个连接需要三次握手，而终止一个连接要经过四次挥手

三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、为后面的可靠性传送做准备。


TCP 是 HTTP 的传输层协议，所以 HTTP 报文是包裹在 TCP 中发送的

HTTPS = HTTP + SSL 

在 HTTP 加入 TCP 之前使用 SSL 对 HTTP 报文进行加密，防止被拦截泄露信息，但是会有时间损耗（如握手和加密等过程）




# 发送 HTTP 请求

发送请求的过程就是构建 HTTP 请求报文并通过 TCP 包裹发送到服务器


## 请求报文组成


1. 请求行

eg: GET index.html HTTP/1.1

GET: 获取数据

POST: 发送数据

PUT: 新增数据 或 替换数据

DELETE: 删除指定的数据

HEAD: 下载一个大文件前先获取其大小再决定是否要下载

OPTIONS: 预请求

PATCH: 对数据进行部分修改

CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器

TRACE: 回显服务器收到的请求，主要用于测试或诊断


2. 请求报头

3. 请求正文。




# 服务器返回 HTTP 报文


对 TCP 连接处理，对 HTTP 协议进行解析，按照报文格式封装成 HTTP Request对象


## 响应报文组成

1. 状态码

200：请求正常处理

204：请求处理成功，但没有资源可返回

301：请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。

302：请求的资源已被分配了新的 URI，希望用户(本次)能使用新的 URI 访问。

304：客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。

400：请求报文中存在语法错误。

403：请求资源的访问被服务器拒绝了，未获得文件系统的访问授权，访问权限出现某些问题

404：服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用

500：服务器端在执行请求时发生了错误

502：错误通常不是客户端能够修复的，而是需要由途径的 Web 服务器或者代理服务器对其进行修复

503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。


2. 响应报头

3. 响应报文



# 拿到数据渲染页面

1. 解析 HTML 文件构建 DOM 树 

2. 解析 CSS 文件构建渲染树 (重新计算元素的几何属性，并重新构建渲染树，这个过程称为 "重排")

3. 渲染树构建完成后，浏览器把渲染树绘制到屏幕 (完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是 "重绘")

4. JS 解析是由浏览器中的 v8 引擎完成

5. 当文档执行遇到 JS 文件，HTML 文档会停止渲染，等 js 加载并执行完毕后再继续渲染 HTML

6. JS 是单线程运行，就是说，在同一个时间只能做一件事

7. JS 执行机制就可以看做是 一个主线程（同步任务）+ 一个任务队列（异步任务）


# 重绘和重排


## 会触发重排的情况

重排发生的根本原理就是元素的几何属性发生了改变

- 添加或删除可见的DOM元素

- 元素位置改变

- 元素本身的尺寸发生改变

- 内容改变

- 页面渲染器初始化

- 浏览器窗口大小发生改变


## 如何进行性能优化


- 合并所有的改变一次处理。这样就只会修改DOM节点一次，比如改为使用cssText属性实现

```js
// 下面会重排三次
var el = document.querySelector('.el');
el.style.borderLeft = '1px';
el.style.borderRight = '2px';
el.style.padding = '5px';
```

```js
var el = document.querySelector('.el');
el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px';
```


- 还有一种减少重排的方法就是切换类名，而不是使用内联样式的cssText方法

```js
// css 
.active {
  padding: 5px;
  border-left: 1px;
  border-right: 2px;
}
// javascript
var el = document.querySelector('.el');
el.className = 'active';
```


- 批量修改DOM方法

以上2种方式 改变样式最小化仅适用于单个存在的节点。

但是我们需要对DOM元素进行多次修改，比如增加10个dom元素，那么必然会有dom操作，可以用批量修改DOM方法。

批量修改DOM元素的核心思想是三步：

1. 让元素脱离文档流

2. 对元素进行多重改变

3. 将元素带回文档流

display:none隐藏后不占据额外空间，它会产生回流和重绘，而visibility:hidden和opacity:0元素虽然隐藏了，但它们仍然占据着空间，它们俩只会引起页面重绘。

上述三个过程引发2次重排，第一步和第三步，如果没有这两步，可以想象一下，第二步每次对DOM的增删都会引发一次重排。

所以核心思想就是脱离文档流，下面说下三种可以使元素可以脱离文档流的方法，注意，这里不使用css中的浮动&绝对定位，这是风马牛不相及的概念。

- 隐藏元素，进行修改后，然后再显示该元素

```js
// 这种方法造成2次重排，分别是控制元素的显示与隐藏。
let ul = document.querySelector('#mylist');
ul.style.display = 'none';
appendNode(ul, data);
ul.style.display = 'block';
```

- 使用文档片段创建一个子树，然后再拷贝到文档中

```js
// 只在添加文档片段的时候涉及到了一次重排。
// 它设计的目的就是用于更新，移动节点之类的任务，而且文档片段还有一个好处就是，当向一个节点添加文档片段时，添加的是文档片段的子节点群，自身不会被添加进去。不同于第一种方法，这个方法并不会使元素短暂消失造成逻辑问题
let fragment = document.createDocumentFragment();
appendNode(fragment, data);
ul.appendChild(fragment);
```

- 将原始元素拷贝到一个独立的节点中，操作这个节点，然后覆盖原始元素

```js
// 可以看到这种方法也是只有一次重排。总的来说，使用文档片段，可以操作更少的DOM（对比使用克隆节点），最小化重排重绘次数。
let old = document.querySelector('#mylist');
let clone = old.cloneNode(true);
appendNode(clone, data);
old.parentNode.replaceChild(clone, old);
```
