#### 什么算是垃圾数据

在一些数据不被需要的时候，它就是垃圾数据，垃圾数据占用的内存就应该被回收。

例子：
```js
// 创建了一个对象obj在堆内存中
const obj = new Object()
// 给这个对象增加一个属性并赋值，在堆内存中多了[1, 2]
obj.a = [1, 2]
// 然后又把a赋值为对象，在堆内存中多了{'key': 123}
obj.a = {'key': 123}
```
上面代码，a 的指向改变后此时存在堆内存中的[1, 2]最后就变成了垃圾数据



#### 垃圾回收的算法

可以将整个过程想象成从根溢出一个巨大的油漆桶，从一个根节点出发将可到达的对象标记染色， 然后移除未标记的。

##### 分三步：


    1.标记可达值
    
    从根节点出发遍历所有对象，可以遍历到的对象是可达值，没有遍历到的是不可达值。

    浏览器环境的根节点：全局变量 window、DOM 树、存放在栈上的变量。（这些根节点不可能被回收。）

    
    2.回收不可达值所占据的内存

    在所有的可达值标记完成之后，统一清理内存中所有不可达的对象。


    3.做内存整理

    频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫「内存碎片」。

    这时如果需要分配较大的连续内存时，就有可能出现内存不足的情况。

    所以最后一步是整理内存碎片。（有的垃圾回收器不会产生内存碎片，比如副垃圾回收器）




#### 什么时候进行垃圾回收

因为浏览器进行垃圾回收的时候，会暂停JavaScript脚本，等回收完毕再继续执行。

所以什么时候垃圾回收，才可以避免长时间暂停JavaScript脚本。


##### 三个策略

分带收集 / 增量收集 / 闲时收集


##### 分带收集

一句话总结分代回收就是：将堆分为新生代与老生代，多回收新生代，少回收老生代。

这样是为了减少每次需遍历的对象，从而减少每次垃圾回收的耗时。


浏览器将数据分为两种，临时 / 长久 对象。

    临时对象：
        对象在内存中存活的时间很短。比如函数内部声明的变量，或者块级作用域中的变量。
        当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。

    长久对象：
        生命周期很长的对象，比如全局的 window、DOM、Web API ，这类对象可以慢点回收


两种对象对应不同的回收策略，V8 把堆分为新生代和老生代两个区域。

副垃圾回收器负责新生代（存放临时对象的堆）的垃圾回收

主垃圾回收器负责老生代（存放持久对象的堆）的垃圾回收

以上这样就可以实现高效的垃圾回收。


主垃圾回收器（负责老生代回收）

    两个特点：
        对象占用空间大。
        对象存活时间长。
        使用「标记-清除」的算法执行垃圾回收。


副垃圾回收器（负责新生代回收）

    特点：
        被分为两个区域，对象区域 / 空闲区域
        新加入的对象都放在对象区域，等对象区域快满的时候执行一次清理。
            1.先给所有垃圾标记
            2.可达值复制到空闲区域，有序排列一遍。（所以不会有碎片不需整理）
            3.复制完成后，对象区域会和空闲区域进行对调。
            这样，就完成了垃圾回收。

    因为副垃圾回收器操作比较频繁，所以为了回收速度，一般新生区的空间会被设置得比较小。




##### 增量收集

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。

所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。

这样就解决了长时间停顿的问题。




##### 闲时收集

垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。





#### 浏览器中 值类型、引用类型 的内存都是何时释放

引用类型：在没有引用之后，通过 V8 自动回收。

值类型：闭包的情况下，等没有引用才会被 V8 回收。非闭包的情况，等待新生代的对象区和空闲区进行对调时回收。



#### 哪些情况会导致内存泄露

内存泄露是指你「用不到」（不可达）的变量，依然占居着内存空间，内存空间不能被再次利用起来。

Vue 中内存泄漏：
    监听在 window/body 等事件没有解绑
    绑在 EventBus 的事件没有解绑
    Vuex 的 $store，watch 了之后没有 unwatch
    使用第三方库创建，没有调用正确的销毁函数

解决办法：beforeDestroy 中及时销毁
    绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener。
    观察者模式 $on，$off处理。
    如果组件中使用了定时器，应销毁处理。
    如果在 mounted/created 钩子中使用了第三方库初始化，对应的销毁。
    使用弱引用 weakMap、weakSet。



#### 闭包会导致内存泄露吗

闭包里面的变量就是我们需要的变量，不能说是内存泄露。

这个误解是因为 IE bug，在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。



#### weakSet 和 Map Set

ES6 新增了两个数据结构 WeakMap、WeakSet，就是为了解决内存泄漏的问题。

它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。