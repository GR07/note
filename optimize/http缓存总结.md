http 缓存：


缓存副本必须满足以下任一条件 浏览器才认为它是有效的。

1.新鲜度，是否过期（强缓存）

2.验证机制，是否和服务器的一致（协商缓存）



强缓存：

1.Pragma

2.Expires

3.Cache-Control


协商缓存：

1.ETag / If-Not-Match （响应 / 请求）

2.Last-Modified / If-Modified-Since （响应 / 请求）



强缓存：

效果：如果缓存没有过期（Cache-Control 的 max-age）会直接使用浏览器的缓存数据，不会再向服务器发送任何请求，强制缓存生效时，状态码为200。

优点：这种方式页面的加载速度是最快的，性能也是很好的。

缺点：但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。

强缓存选择：主流选用 Cache-Control


协商缓存：

效果：第二次请求浏览器会带上响应的 ETag 对应的 If-Not-Match  Last-Modified 对应的 If-Modified-Since，

服务器接收到这两个参数后会做比较，如果一致返回 304 表示请求的资源没有修改，可以直接在缓存中拿，否则，服务器会直接返回新资源。


优点：当强缓存过期后，如果资源仍然没有修改，也会通过收到 304 去缓存中拿，提高缓存复用率。

场景：如果 max-age=3600 过期了然后向服务器发了请求，那么是否就一定要读取回该资源的整个实体内容？是不是可以我们发一个请求，然后服务器收到后告诉我们 你想要的这个资源在服务器并没有修改，然后我们收到后直接从浏览器里拿缓存就好了。

ETag 缺点：可以理解为它就是根据文件信息通过计算生成的 MD5 值，那么如果在分布式环境下比如我们 cdn 就会有个问题，不同的服务器用了不同的算法 ETag值就会不一致，还有计算需要性能消耗。

Last-Modified 缺点：它的值是服务器资源最后修改时间，所以只要资源修改无论内容有没有变化都会返回新资源，还有某些服务器可能不能精准的获取到最后修改时间。

Last-Modified 场景：如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，那么时间就对不上了，会再重新下载资源。

协商缓存选择：

ETag 是服务器生成对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。

Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

注意：同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。

在较新的 nginx 上默认是同时开启了 Last-Modified 与 ETag 这两个功能的。





缓存实践：

Cache-Control：public和private的选择

如果用了CDN，需要关注下这个值。CDN厂商一般会要求 cache-control 的值为 public，提升缓存命中率。

如果缓存命中率很低，而访问量很大的话，可以看下是不是设置了private，no-cache这类的值。

如果定义了max-age，可以不用再定义public，它们的意义是一样的。


no-cache 和 no-store 区别：

no-cache和no-store都是HTTP协议头Cache-Control的值。

no-store

彻底禁用缓冲，所有内容都不会被缓存到缓存或临时文件中。

no-cache

在浏览器使用缓存前，会往返对比ETag，如果ETag没变，返回304，则使用缓存。

除了no-cache和no-store，Cache-Control头的取值还有：

public

所有内容都将被缓存（客户端和代理服务器都可缓存）

private

内容只缓存到私有缓存中（仅客户端可以缓存，代理服务器不可缓存）

max-age=xxx

缓存的内容将在 xxx 秒后失效，这个选项只在HTTP1.1可用，并如果和Last-Modified一起使用时，优先级较高。