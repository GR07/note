
# 编译器的核心由三部分组件

- 解析：将类 html 模板转换为 AST 对象

- 优化：也称为静态标记，遍历 AST 对象，标记每个节点是否为静态节点，以及标记出静态根节点

- 生成渲染函数：将 AST 对象生成渲染函数


# 如何将类 html 模版字符串转换成 AST 对象

类 html 模板指的就是 <template>，并不是一个真正的 html，不可直接运行在浏览器。



# $mount

执行编译器的入口，就做了一件事情，得到组件的渲染函数，将其设置到 this.$options 上

```js
/**
 * 通过 rollup 的配置文件一步步的去找 /src/platforms/web/entry-runtime-with-compiler.js
 * 运行时的 Vue.js 包就没有这部分的代码，通过 打包器 结合 vue-loader + vue-compiler-utils 进行预编译，将模版编译成 render 函数
 * 
 */

// 拷贝一份
const mount = Vue.prototype.$mount

// 覆写 $mount

// 初始化执行的 $mount 就是这个
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {

  // 获取挂载点
  el = el && query(el)

  // 挂载点不能是 body 或者 html
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  // 配置项
  const options = this.$options
  
  // 如果用户提供了 render 配置项，则直接跳过编译阶段

  // 否则进入编译阶段，解析 template 和 el，并转换为 render 函数。优先级：render > template > el
  if (!options.render) {

    let template = options.template

    // 优先用 template 模板

    // 内部只有一个目的 就是 得到 innerHtml
    if (template) {

      // 处理 template 选项
      if (typeof template === 'string') {

        // { template: '#app' }
        if (template.charAt(0) === '#') {

          // { template: '#app' }，template 是一个 id 选择器，则获取该元素的 innerHtml 作为模版
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {

        // template 是一个正常的元素，依然获取其 innerHtml 作为模版
        template = template.innerHTML

      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }

    } else if (el) {

      // 如果没有提供 template

      // 那只好用 el 选项

      // 用 el 选择器的 outerHtml 作为模版，具体实现在下面
      template = getOuterHTML(el)
    }

    // 如果通过前面拿到了 innerHtml 或 outerHtml，表明 模版就绪，可以进入编译阶段
    if (template) {

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      // 编译模版后，得到 动态渲染函数render 和 静态渲染函数staticRenderFns
      const { render, staticRenderFns } = compileToFunctions(template, {

        // 在非生产环境下，编译时记录标签属性在模版字符串中开始和结束的位置索引
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        // 界定符，默认 {{ }}
        delimiters: options.delimiters,
        // 是否保留注释
        comments: options.comments
      }, this)

      // 将两个渲染函数放到 this.$options 上
      options.render = render
      // 静态 不会变化的节点，就是没有响应式数据的节点
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }

  // 用户提供了 render 配置项，则直接跳过编译阶段
  
  // 直接执行挂载
  return mount.call(this, el, hydrating)
}

function getOuterHTML (el: Element): string {
  // 如果元素的outerHTML存在
  if (el.outerHTML) {
    // 返回该元素及本身的所有HTML代码
    return el.outerHTML
  } else { // 如果该元素的outerHTML属性不存在
    // 创建一个DIV
    const container = document.createElement('div')
    // 向DIV中添加这个el
    container.appendChild(el.cloneNode(true))
    // 此时返回container的innerHTML就可以得到该元素即本身的HTML代码
    return container.innerHTML
  }
}

```

# compileToFunctions

/src/compiler/to-function.js

核心执行：const compiled = compile(template, options)

```js
/**
 * 1、执行编译函数，得到编译结果 -> compiled
 * 2、将编译得到的字符串代码通过 new Function(codeStr) 转换成可执行的函数
 * 3、缓存编译结果
 * @param { string } template 字符串模版
 * @param { CompilerOptions } options 编译选项
 * @param { Component } vm 组件实例
 * @return { render, staticRenderFns }
 */
return function compileToFunctions(
  template: string,
  options?: CompilerOptions,
  vm?: Component
): CompiledFunctionResult {
  // 传递进来的编译选项
  options = extend({}, options)
  // 日志
  const warn = options.warn || baseWarn
  delete options.warn

  // 如果有缓存，则跳过编译，直接从缓存中获取上次编译的结果
  const key = options.delimiters
    ? String(options.delimiters) + template
    : template
  if (cache[key]) {
    return cache[key]
  }

  // 执行编译函数，得到编译结果

  // 编译结果，compiled.render 就是一个字符串
  const compiled = compile(template, options)

  
  const res = {}
  const fnGenErrors = []
  // 使用 new Function()，把 compile() 编译出来的 compiled.render 字符串，转成函数
  res.render = createFunction(compiled.render, fnGenErrors)
  // 同上
  res.staticRenderFns = compiled.staticRenderFns.map(code => {
    return createFunction(code, fnGenErrors)
  })

  // 这句代码在返回编译结果的同时，将结果缓存，这样下一次发现如果 cache 中存在相同的 key则不需要再次编译，直接使用缓存的结果就可以了。
  return (cache[key] = res)
}

```


# compile

/src/compiler/create-compiler.js

真正的编译函数

核心执行：const compiled = baseCompile(template.trim(), finalOptions)

```js
/**
 * 编译函数，做了两件事：
 *   1、选项合并，将 options 配置项 合并到 finalOptions(baseOptions) 中，得到最终的编译配置对象
 *   2、调用核心编译器 baseCompile 得到编译结果
 *   3、将编译期间产生的 error 和 tip 挂载到编译结果上，返回编译结果
 * @param {*} template 模版
 * @param {*} options 配置项
 * @returns 
 */
function compile(
  template: string,
  options?: CompilerOptions
): CompiledResult {

  // 以平台特有的编译配置为原型创建编译选项对象
  const finalOptions = Object.create(baseOptions)
  const errors = []
  const tips = []

  // 日志，负责记录将 error 和 tip
  let warn = (msg, range, tip) => {
    (tip ? tips : errors).push(msg)
  }

  // 如果存在编译选项，合并 options 和 baseOptions
  if (options) {
    // 开发环境走
    if (process.env.NODE_ENV !== 'production' && options.outputSourceRange) {
      // $flow-disable-line
      const leadingSpaceLength = template.match(/^\s*/)[0].length

      // 增强 日志 方法
      warn = (msg, range, tip) => {
        const data: WarningMessage = { msg }
        if (range) {
          if (range.start != null) {
            data.start = range.start + leadingSpaceLength
          }
          if (range.end != null) {
            data.end = range.end + leadingSpaceLength
          }
        }
        (tip ? tips : errors).push(data)
      }
    }

    /**
     * 将 options 中的配置项合并到 finalOptions
     * 
     * baseOptions 就是各种处理模板的逻辑，比如 v-model 该怎么处理
     */

    // 合并自定义 module
    if (options.modules) {
      finalOptions.modules =
        (baseOptions.modules || []).concat(options.modules)
    }
    // 合并自定义指令
    if (options.directives) {
      finalOptions.directives = extend(
        Object.create(baseOptions.directives || null),
        options.directives
      )
    }
    // 拷贝其它配置项
    for (const key in options) {
      if (key !== 'modules' && key !== 'directives') {
        finalOptions[key] = options[key]
      }
    }
  }

  // 日志
  finalOptions.warn = warn

  // 到这里为止终于到重点了，调用核心编译函数，传递模版字符串和最终的编译选项，得到编译结果
  // 前面做的所有事情都是为了构建平台最终的编译选项
  const compiled = baseCompile(template.trim(), finalOptions)

  if (process.env.NODE_ENV !== 'production') {
    detectErrors(compiled.ast, warn)
  }
  // 将编译期间产生的错误和提示挂载到编译结果上
  compiled.errors = errors
  compiled.tips = tips

  // 返回编译结果
  return compiled
}

```

# baseOptions

/src/platforms/web/compiler/options.js

```js
export const baseOptions: CompilerOptions = {
  expectHTML: true,
  // 处理 class、style、v-model
  modules,
  // 处理指令
  // 是否是 pre 标签
  isPreTag,
  // 是否是自闭合标签
  isUnaryTag,
  // 规定了一些应该使用 props 进行绑定的属性
  mustUseProp,
  // 可以只写开始标签的标签，结束标签浏览器会自动补全
  canBeLeftOpenTag,
  // 是否是保留标签（html + svg）
  isReservedTag,
  // 获取标签的命名空间
  getTagNamespace,
  staticKeys: genStaticKeys(modules)
}

```