# 异步更新的入口

setter 函数中的 dep.notify()



# dep.notify

第一步：通知 dep 中的所有 watcher，执行 watcher.update() 方法

```js
notify () {
  // stabilize the subscriber list first
  const subs = this.subs.slice()
  // 遍历 dep 中存储的 watcher，执行 watcher.update()
  for (let i = 0, l = subs.length; i < l; i++) {
    subs[i].update()
  }
}

```

# watcher.update

第二步：根据 watcher 配置项，决定接下来怎么走，一般是 queueWatcher

```js
update () {
  /* istanbul ignore else */
  if (this.lazy) {

    // 懒执行的api走这里，比如 computed

    // 将 dirty 置为 true，组件更新后，数据再次改变时，重新执行 computed 回调计算新值，然后缓存到 watcher.value

    this.dirty = true

  } else if (this.sync) {

    // 如果是同步，则直接执行 watcher.run() 直接渲染视图

    // 在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项（vue文档里没写）

    this.run()

  } else {

    // 异步更新时一般都这里，将当前的单个 watcher 放入全局定义的 queue 数组

    // this 就是当前的 watcher，就是 dep 收集的其中的一个 watcher

    queueWatcher(this)
  }
}

```


# queueWatcher

第三步：将当前数据的，dep 收集的其中的一个 watcher 放入全局定义的 queue 数组

```js
// 存放 watcher 数组
const queue: Array<Watcher> = []
// 用于去重
const has = {}

export function queueWatcher (watcher: Watcher) {
  const id = watcher.id

  // 利用 id 判重，如果 watcher 已经存在，则跳过，不会重复入队

  // 这里也解释了同一个 watcher 被多次触发，只会被推入到队列中一次
  
  if (has[id] == null) {
    
    // 缓存一下，置为 true
    has[id] = true

    if (!flushing) {

      // 说明如果当前没有处于刷新队列过程中，watcher 直接入队
      queue.push(watcher)

    } else {

      // 如果已经在刷新队列过程中了

      // 根据 id 从小到大排序，将当前 watcher 放入队列中
      
      // 就是为了保证这个数组是有序的。（后面有用）

      let i = queue.length - 1
      
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      // 将当前 watcher 放入到相应位置队列中
      queue.splice(i + 1, 0, watcher)
    }

    // waiting 开关

    // false 表示当前浏览器的异步任务队列中没有 flushScheulerQueue 函数
    
    if (!waiting) {

      waiting = true

      if (process.env.NODE_ENV !== 'production' && !config.async) {

        // 非生产环境 & 同步 走这里

        // 这里是同步执行 Watcher 队列

        // 一般不会走这儿，Vue 默认是异步执行，如果改为同步执行，性能会大打折扣（会阻塞后面的同步代码）

        flushSchedulerQueue()

        return
      }

      // 常用到的 this.$nextTick、Vue.nextTick

      // 如果不传入 回调函数（flushSchedulerQueue），直接执行的话就是同步更新 Dom 了

      nextTick(flushSchedulerQueue)
    }
  }
}

```

# flushSchedulerQueue

第四步前置：这就是传入 nextTick 的 cb 函数，会被推进全局的 callbacks 数组，最后在浏览器的任务队列执行。

记住：每一个 flushSchedulerQueue 函数，就是对应一个属性 this.a 需要更新的所有依赖视图

```js

// 这里就是把 当前属性收集的 Watcher 数组，依次执行 Watcher.run() 更新视图


// 因为 subs[i].update() 循环是一个同步的过程，全局的 callbacks 数组最终是异步执行

// 所以 callbacks 数组遍历执行的时候，可以 run 到，所有变更的属性对应的所有 watcher

function flushSchedulerQueue () {
  currentFlushTimestamp = getNow()

  // 表示 现在的 queue 队列正在执行刷新
  flushing = true

  let watcher, id

  // 由小到大排序的作用：

  // 1.保证父组件的 watcher 先执行，再执行子组件的 watcher，（如子先父后，则子会被执行2次）

  // 2.用户watcher先于渲染watcher执行，（因为用户监视器是在渲染监视器之前创建的）

  // 3.当父组件在执行时，如果子组件被销毁了，可以跳过子组件的执行

  queue.sort((a, b) => a.id - b.id)

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
  }
```


# nextTick

```js
// 全局数组，用于存放 flushSchedulerQueue 回调函数
const callbacks = []

// pending 是个开关，false 时，加入异步任务队列，很重要，下面有解释。
let pending = false

// 最终推入到浏览器任务队列的函数
function flushCallbacks () {

  // 当 flushCallbacks() 在任务队列中执行的时候，pending 开关重置，表示可以加入下一个 flushCallbacks 函数到异步任务队列了
  pending = false
  
  const copies = callbacks.slice(0)

  // 清空全局的 callbacks
  callbacks.length = 0

  // 执行所有的 flushSchedulerQueue() 函数
  
  // 也就是执行 当前事件循环轮次内 所有变更的属性的 Watcher

  // 也包括当前事件循环轮次内 用户自己手动调用 this.$nextTick 传入的回调
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

export function nextTick (cb?: Function, ctx?: Object) {

  let _resolve;

  // 把传入的 cb 回调函数加入 callbacks 数组
  callbacks.push(() => {

    if (cb) {

      // 给 cb 回调加上 try-catch 错误捕获

      // flushSchedulerQueue 已经是框架自己定义的函数，执行已经很安全了，为什么还要加 try-catch

      // 因为有可能是 用户在组件内使用 this.$nextTick()，用户写的代码不确定因素就太多了。

      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  // 把 callbacks 数组的执行，加入到浏览器异步任务队列里，等待事件循环去执行

  if (!pending) {

    // pending 是个开关，false 时，加入异步任务队列

    // 这个开关的作用，就是保证 浏览器的任务队列里永远只会存在一个 flushCallbacks 函数

    // 只有当 flushCallbacks() 在任务队列中执行的时候，pending 开关才会重置，才可以加入下一个 flushCallbacks 函数

    pending = true;

    // 这个就是 nextTick 的核心

    // 将全局函数 flushCallbacks 也就是 callbacks 数组的执行，放到浏览器的异步任务队列里

    timerFunc();
  }

  // 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve;
    });
  }
}
```










# Vue 异步更新策略

- 例子

```js
data: {
  message: '原始值'
}

// 修改 数据
this.message = '修改后的值1'
this.message = '修改后的值2'
this.message = '修改后的值3'

// 获取 dom
console.log(vm.$el.textContent) // 打印 '原始值'

// 这时候想获取最新的 DOM 节点，却发现获取到的是旧值

// 这是因为 message 数据在发现变化的时候，vue 并不会立刻去更新 Dom，而是将修改数据的操作放在了一个异步操作队列中

// 在下一个事件循环 “NextTick” 中，Vue 刷新队列并执行实际 (已去重的) Watcher（更新视图）

// vue 为了避免频繁的操作 DOM，采用异步方式更新 DOM，这就是 Vue 中的异步更新策略。
```


- 第三步


https://juejin.cn/post/6844904169967452174

https://juejin.cn/post/6951568091893465102

https://juejin.cn/post/6844903494365741070
