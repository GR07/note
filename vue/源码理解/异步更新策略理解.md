# Vue 异步更新策略


- 先思考一个问题
```js
// 在vue中 如果数据被连续改变3次，dom视图是否会被更新3次
this.a = 1
this.a = 2
this.a = 3
```
- 答案：只更新最后一次的数据改变，vue为了避免频繁的操作DOM，采用异步的方式更新DOM，这就是Vue中的异步更新策略。

- 上面场景就是同一个 watcher 被多次触发，只会被推入到队列中一次。

- 然后，在下一个的事件循环 “NextTick” 中，Vue 刷新队列并执行实际 (已去重的) 工作（更新视图textNODE）

# 实现流程

当触发某个数据的 setter 方法后，它的 setter 函数会通知闭包中的 Dep，Dep 则会调用它管理的所有 Watch 对象。触发 Watch 对象的 update 去更新。



- 第一步

从代码中可以看到，当数据变化的时候会调用 queueWatcher(this) 函数，这是 vue 异步更新队列的方式。

```js
/*调度者接口，当依赖发生改变的时候进行回调 */
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      /*同步则执行run直接渲染视图*/
      this.run()
    } else {
      /*异步推送到观察者队列中，下一个tick时调用。*/
      queueWatcher(this)
    }
  }
```


- 第二步

从 queueWatcher 代码中看出 Watch 对象并不是立即更新视图，而是被 push 进了一个队列 queue，此时状态处于 waiting 的状态

这时候会继续会有 Watch 对象被 push 进这个队列 queue（因为 this.a 属性可能被多个视图使用，也就是被多个watcher观察）等到下一个 NextTick 运行时将这个队列 queue 全部拿出来 run 一遍，这些 Watch 对象才会被遍历取出，更新视图。

注意：id重复的Watcher不会被多次加入到queue中去。这也解释了同一个watcher被多次触发，只会被推入到队列中一次。
```js
 /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/
export function queueWatcher (watcher: Watcher) {
  /*获取watcher的id*/
  const id = watcher.id
  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i >= 0 && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
```

- 第三步


https://juejin.cn/post/6844904169967452174

https://juejin.cn/post/6951568091893465102

https://juejin.cn/post/6844903494365741070





1. 改变属性触发 setter 函数，对比值是否改变，改变则通知 dep 中的所有 watcher，执行 watcher.update() 方法

2. update 函数，根据watcher里面的属性，决定接下来怎么走，computed / watch / queueWatcher（一般都是走queue）

3. queueWatcher 函数将 单个watcher 加入 watcher队列，内部包括了利用hash去重的过程，再根据标识判断是否处于更新状态，没有则入队，有的话，根据watcher.id的大小，插入到相应位置，保证先创建的 watcher 先执行

4. 最后把 flushSchedulerQueue 函数加入到 nextTick() 内部的 callBacks数组，等待事件循环去挨个执行 callBacks数组的每一个watcher函数
