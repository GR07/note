# 异步更新的入口

setter 函数中的 dep.notify()



# dep.notify

第一步：通知 dep 中的所有 watcher，执行 watcher.update() 方法

```js
notify () {
  // stabilize the subscriber list first
  const subs = this.subs.slice()
  // 遍历 dep 中存储的 watcher，执行 watcher.update()
  for (let i = 0, l = subs.length; i < l; i++) {
    subs[i].update()
  }
}

```

# watcher.update

第二步：根据 watcher 配置项，决定接下来怎么走，一般是 queueWatcher

```js
update () {
  /* istanbul ignore else */
  if (this.lazy) {

    // 懒执行的api走这里，比如 computed

    // 将 dirty 置为 true，可以让 computedGetter 执行时重新计算 computed 回调函数的执行结果

    this.dirty = true

  } else if (this.sync) {

    // 同步则执行 run 直接渲染视图

    // 同步执行，在使用 vm.$watch 或者 watch 选项时可以传一个 sync 选项（vue文档里没写）

    this.run()

  } else {
    // 异步更新时一般都这里，将 watcher 放入全局定义的 queue 数组
    queueWatcher(this)
  }
}

```


# queueWatcher

第三步：将当前属性收集的每一个 Watcher 放入全局定义的 queue 数组

```js
export function queueWatcher (watcher: Watcher) {
  const id = watcher.id

  // 利用 id 判重，如果 watcher 已经存在，则跳过，不会重复入队

  // 这里也解释了同一个 watcher 被多次触发，只会被推入到队列中一次
  
  if (has[id] == null) {
    
    // 缓存一下，置为 true
    has[id] = true

    if (!flushing) {

      // 说明如果当前没有处于刷新队列过程中，watcher 直接入队
      queue.push(watcher)

    } else {

      // 如果已经在刷新队列过程中了

      // 根据 id 从小到大排序，将当前 watcher 放入队列中
      
      // 就是为了保证这个数组是有序的。（后面有用）

      let i = queue.length - 1
      
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      // 将当前 watcher 放入到相应位置队列中
      queue.splice(i + 1, 0, watcher)
    }

    // 这个 waiting 开关
    if (!waiting) {
      // false 表示当前浏览器的异步任务队列中没有 flushScheulerQueue 函数
      waiting = true

      if (process.env.NODE_ENV !== 'production' && !config.async) {

        // 非生产环境走这里

        // 这里是同步执行 Watcher 队列

        // 一般不会走这儿，Vue 默认是异步执行，如果改为同步执行，性能会大打折扣

        flushSchedulerQueue()

        return
      }
      /**
       * 熟悉的 nextTick => vm.$nextTick、Vue.nextTick
       *   1、将 回调函数（flushSchedulerQueue） 放入 callbacks 数组
       *   2、通过 pending 控制向浏览器任务队列中添加 flushCallbacks 函数
       */
      nextTick(flushSchedulerQueue)
    }
  }
}

```


# Vue 异步更新策略


- 先思考一个问题
```js
// 在vue中 如果数据被连续改变3次，dom视图是否会被更新3次
this.a = 1
this.a = 2
this.a = 3
```
- 答案：只更新最后一次的数据改变，vue为了避免频繁的操作DOM，采用异步的方式更新DOM，这就是Vue中的异步更新策略。

- 上面场景就是同一个 watcher 被多次触发，只会被推入到队列中一次。

- 然后，在下一个的事件循环 “NextTick” 中，Vue 刷新队列并执行实际 (已去重的) 工作（更新视图textNODE）

# 实现流程

当触发某个数据的 setter 方法后，它的 setter 函数会通知闭包中的 Dep，Dep 则会调用它管理的所有 Watch 对象。触发 Watch 对象的 update 去更新。



- 第三步


https://juejin.cn/post/6844904169967452174

https://juejin.cn/post/6951568091893465102

https://juejin.cn/post/6844903494365741070





1. 改变属性触发 setter 函数，对比值是否改变，改变则通知 dep 中的所有 watcher，执行 watcher.update() 方法

2. update 函数，根据watcher里面的属性，决定接下来怎么走，computed / watch / queueWatcher（一般都是走queue）

3. queueWatcher 函数将 单个watcher 加入 watcher队列，内部包括了利用hash去重的过程，再根据标识判断是否处于更新状态，没有则入队，有的话，根据watcher.id的大小，插入到相应位置，保证先创建的 watcher 先执行

4. 最后把 flushSchedulerQueue 函数加入到 nextTick() 内部的 callBacks数组，等待事件循环去挨个执行 callBacks数组的每一个watcher函数
