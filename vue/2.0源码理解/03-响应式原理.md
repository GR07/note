# 响应式是什么

数据模型仅仅是普通的 JavaScript 对象，而当你修改它们时，视图会进行更新。



# 响应式入口 

- initState() 函数内部的 observe() 函数。

- 在处理 props、data 的过程中，才会去真正去响应式数据处理。



# observe() 真正处理响应式数据的入口

- data 选项，最后会经过 observe() 处理为响应式。

- props 选项，因为是对象，所以只需通过 defineReactive() 直接处理即可。（def在obs的内部调用）



# defineReactive 雏形

- 利用闭包存储 val 值，替代全局变量的形式

- 利用闭包的缓存，更改时也可以拿到上一次的值

```js
// 拦截
function defineReactive (data, key, val) {
  Object.defineProperty(data, key, {
    get () {
      return val
    },
    set (newVal) {
      if (newVal === val) {
        return
      }
      val = newVal
    }
  })
}

let obj = {
  a: 'a',
  b: 'b',
  guor: {
    g: 'g',
    u: {
      r: 'r'
    }
  }
}

// 依次手动添加
defineReactive(obj, 'a', 0)
// 依次手动添加
defineReactive(obj, 'b', 0)

obj.a = 10
obj.b = 20

console.log(obj.a);
console.log(obj.b);


// 优化
// 手动添加改为递归自动添加
function toRawType (val) {
  return Object.prototype.toString.call(val).slice(8, -1)
}
// 递归 + 拦截 （为了处理对象嵌套）
function recursion (data) {
  Object.keys(data).forEach((key) => {
    if (toRawType(data[key]) === 'Object') {
      recursion(data[key])
    } else {
      defineReactive(data, key, data[key])
    }
  })
}

recursion(obj)

console.log(obj.b);
console.log(obj.guor.g);
obj.guor.u.r = 888
console.log(obj.guor.u.r);
```



# 循环调用方式添加（也就是 vue2 中的原理）


- 第一步：调用 observe 入口函数

```js

// 主要是实例化 new Observer

// 如果 value 已经是响应式数据，就不需要再创建 Observer 实例，避免重复侦测 value 变化的问题

export default function observe(value) {

  // 如果 value 不是对象，直接退出
  if (typeof value !== 'object') return;

  let ob;

  // 是否已经被处理成响应式了
  if (typeof value.__ob__ !== 'undefined') {
    ob = value.__ob__;
  } else {
    // 没有 则去处理
    ob = new Observer(value);
  }

  // 不用管返回值是什么东西，这里用不到
  return ob;
}
```


- 第二步：实现 Observer 类

```js

// 处理传入的对象，把对象每个层级的属性都处理为响应式

// 也就是把每一层对象的 __ob__ 属性上都实例化一个 Observer

export default class Observer {
  // 构造器
  constructor(value) {
    // 给实例添加__ob__属性，值是当前Observer的实例，不可枚举
    // __ob__的作用是用来标记当前 value 是否已经被 Observer 转换成了响应式数据了
    // 可以通过 当前层对象.__ob__ 访问
    def(value, '__ob__', this, false);
    
    // 这里就是 遍历当前层级对象的每个 key ，用 defineProperty 劫持
    this.walk(value);
  }
  walk(value) {
    for (let key in value) {
      // 内部就是 defineProperty getter/setter 的封装
      defineReactive(value, key);
    }
  }
}

/**
 * 工具函数：给对象添加 __ob__ 属性，值为 Observer 实例
 * @param {*} obj 
 * @param {*} key 
 * @param {*} value 
 * @param {*} enumerable 
 */
export default function def(obj, key, value, enumerable) {
  Object.defineProperty(obj, key, {
    value,
    enumerable,
    writable: true,
    configurable: true,
  });
}
```


- 第三步：defineReactive 的实现，对 defineProperty 封装

```js
/**
 * 给对象 data 的属性 key 定义监听
 * @param {*} data 传入的数据
 * @param {*} key 监听的属性
 * @param {*} value 闭包环境提供的周转变量
 */
export default function defineReactive(data, key, value) {
  
  // 赋值给闭包变量
  if (arguments.length === 2) {
    value = data[key];
  }
  
  // 子元素如果是对象的话，再从头开始执行 observe，形成递归
  
  let childOb = observe(value) // 不用管这个 childOb 赋值，这里没用
  
  Object.defineProperty(data, key, {
    // 可枚举 可以for-in
    enumerable: true,
    // 可被配置，比如可以被delete
    configurable: true,

    get() {

      console.log(`访问则触发，所以这里可以做 watcher 的事情了`)

      return value;

    },

    set(newValue) {

      console.log(`赋值则触发，所以这里可以做 watcher 的事情了`)

      // 如果新旧值一样，则退出
      if (value === newValue) return;

      // 把新值赋值给闭包变量
      value = newValue;
      
      // obj.a.b = 123 赋值了新值后，新值也要从头走一遍 observe() 
      childOb = observe(newValue)

    },
  });
}
```


- 运行

```js
// 数据对象
let obj = {
  a: '123',
  b: {
    c: {
      d: ''
    }
  }
}

// 入口
observe(obj)

// 触发
obj.b.c.d = 'aaa'

```





# 接上面函数的分支逻辑，对数组类型响应式处理

上面的只包含了 对象的响应式处理方式，下面是数组的处理。

- 第一步：分支逻辑入口在 Observer 类

```js
// 数组处理的入口 在 Observer 类 里面
export default class Observer {

  constructor(value) {

    def(value, '__ob__', this, false);
    
    if (Array.isArray(value)) {

      // 如果是数组，改写当前数组数据的原型
      Object.setPrototypeOf(value, arrayMethods)

      // 然后遍历数组，逐项响应式
      this.observeArray(value)

    } else {

      // 这里是对象的处理
      this.walk(value);

    }
    
  }
  
  observeArray(value) {
    for (let i = 0, len = value.length; i < len; i ++) {

      // 数组的每一项再去，挨个走一遍 observe()

      // 到这里，也就明白了为什么数组中的项如果不是对象，是不会通过 defineProperty 绑 get set 的

      // 因为传入 observe 的值如果不是对象（obj/arr），则会直接退出

      observe(value[i])

    }
  }
}
```


- 第二步：对数组类型的数据，改写原型

```js

// 拿到数组原型对象
const arrayPrototype = Array.prototype

// 创建一个新的对象
export const arrayMethods = Object.create(arrayPrototype)

// 一共七种 API 改写
const methodsNeedChange = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

methodsNeedChange.forEach(methodName => {

  // 备份 原始的 push 方法
  const original = arrayPrototype[methodName]

  // 给 arrayMethods 对象，从新定义 push 方法，def 就是上面的工具函数（defineProperty）
  def(arrayMethods, methodName, function () {

    console.log('这个function 就是 重写的 push 内部，每次执行 push 都会进来')

    // 用 原始的 push 执行一下，arguments 接收 push 时传入的参数，就完成了数组的 push 操作
    
    const result = original.apply(this, arguments) // this 指向的就是 调用 push 的数组数据
    
    // 调用 push 时传入的参数
    const args = [...arguments]
    
    // 这个就是 上面的 Observer 实例对象
    const ob = this.__ob__

    let inserted

    // 这里 switch 只是为了给，通过数组操作新增的项，也增加响应式处理。

    // （共三种 push、unshift、splice）因为这三个方法都是往数组里面新增项

    switch (methodName) {
      case 'push':
      case 'unshift':

        inserted = args

        break

      case 'splice':

        // 因为调用 splice 方法时，第三个参数才是需要插入到数组的项（splice(x, x, x)）
        inserted = args.slice(2)

        break

    }

    if (inserted) {
      // 把新加入数组的项，使用 Observer 的实例方法 observeArray 挨个走一遍 observe()
      ob.observeArray(inserted)
    }
    
    // 最后要返回值

    // 例如：调用某些原生数组方法 let a = [1, 2].pop() // a 返回的就是被删除的元素

    return result

  }, false)
})
```


- 运行

```js
// 数据对象
let obj = {
  a: [1, 2, 4, 5],
  b: {
    c: {
      d: ''
    }
  },
}
// 入口
observe(obj)

// 触发
obj.a.push(6, 7, 9)
console.log(obj.a)

```






# 依赖收集

- 什么是依赖？

需要用到 abc 这个数据的地方，这个地方就称为依赖。

把这些 "地方" 都收集起来，这种行为就叫依赖收集。

- vue1.x，细颗粒度依赖，只要用到数据的 DOM，都是依赖

- vue2.x，中颗粒度依赖，只有用到数据的 组件级别，才是依赖（所以 vue2 ，当一个 abc props 传给组件，只要abc改变，整个组件都会重新渲染（diff-vnode-render））


如何收集依赖？

- 在 getter 中收集这些依赖，在 setter 中循环触发收集的依赖。

因为只要用到这个数据，就会触发 getter，所以谁触发的 getter 就把谁收集起来。


- 实现步骤

1. 把依赖收集的代码封装成一个 Dep 类（依赖的缩写dependence）专门用来管理依赖，每个 Observer 实例中都有一个 Dep 实例。
  - Dep 使用发布订阅模式，数据发生变化，则会循环 依赖列表（Watcher数组），挨个通知。


2. Watcher 是一个中介

  - getter 时，调用 dep.depend() 收集依赖（依赖就是 Watcher）
    哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中

  - setter 时，调用 dep.notify() 触发通知（通知的也是 Watcher）



```js
// Dep 是发布订阅模式
// 其实传入对象里面的每一个对象都会有一个 Dep 实例
// Dep.js
let uid = 0
export default class Dep {
  constructor () {
    this.id = uid ++
    // 用数组存储自己的订阅者（也就是 new Watcher() 实例）
    // subscribes 订阅者的意思
    this.subs = []
  }
  // 添加订阅（Watcher实例）
  addSub(sub) {
    this.subs.push(sub)
  }
  // 用于调用添加订阅
  depend () {
    // target 是全局一个指定的位置，用于存当前数据的 Watcher 实例
    // getter 函数中，从 Dep.target 中拿到当前数据的 watcher
    if (Dep.target) {
      this.addSub(Dep.target)
    }
  }
  // 通知更新（通知每一个Watcher实例）
  notify () {
    // 拷贝一份
    const subs = this.subs.slice()
    for (let i = 0, len = subs.length; i < len; i ++) {
      subs[i].update()
    }
  }
}

export default class Observer {
  // 构造器
  constructor(value) {
    // 每层的对象数据上 __ob__ 都有一个 Observer，每个 Observer 里面又有一个Dep
    // 这里的实例化，是为了把 Dep 绑定到 Observer 上面
    this.dep = new Dep()

    def(value, '__ob__', this, false);
    
    if (Array.isArray(value)) {
      // 
    } else {
      // 
    }
  }
}


export default function defineReactive(data, key, value) {
  const dep = new Dep()
  // 经过 Observer 构造函数 walk 遍历过的，赋值给闭包
  if (arguments.length === 2) {
    value = data[key];
  }
  
  let childOb = observe(value)
  
  Object.defineProperty(data, key, {
    // 可枚举 可以for-in
    enumerable: true,
    // 可被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      // 如果存在 watcher 实例 则收集到数组
      if (Dep.target) {
        dep.depend()
        // 如果有子对象，这里才是将子对象的watcher加入数组 
        if (childOb) {
          childOb.dep.depend()
        }
      }
      return value;
    },
    // setter
    set(newValue) {
      if (value === newValue) return;
      value = newValue;
      
      childOb = observe(newValue)

      dep.notify()
    },
  });
}


methodsNeedChange.forEach(methodName => {
  
  def(arrayMethods, methodName, function () {
    
    if (inserted) {
      // 则使用 Observer 的实例方法 observeArray 再去遍历执行 observe
      ob.observeArray(inserted)
    }
    // 数组改变时，也要去触发 notify
    ob.dep.notify()

    return result
  }, false)
})


export function parsePath (path: string): any {
  // a.b.c.d
  const segments = path.split('.')
  return function (obj) {
    // 一层一层拿到属性 a.b.c.d
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}


export default class Watcher {
  // target 传入的当前数据对象
  // 字符串表达式 a.b.c
  // 回调函数，值改变时需要做的事情。
  constructor (target, expression, callback) {
    this.id = uid ++
    this.target = target
    // parsePath 函数 等待调用，然后获取到值
    this.getter = parsePath(expression)
    this.callback = callback
    this.value = this.get()
  }
  update () {
    this.run()
  }
  get () {
    // 全局的 target = 当前watcher实例
    Dep.target = this
    const obj = this.target
    let value
    try {
      // 获取到值
      value = this.getter(obj)
    } finally {
      Dep.target = null
    }

    return value
  }
  run () {
    this.getAndInvoke(this.callback)
  }
  getAndInvoke (cb) {
    const value = this.get()

    if (value !== this.value || typeof value === 'object') {
      const oldValue = this.value
      this.value = value
      cb.call(this.target, value, oldValue)
    }
  }
}


// 总结过程

// 先 observe > 然后实例 Watcher 所以 Dep.target 就存在了 > 数据改变 > 触发 getter 收集全局 Dep.target > 触发 setter 执行 notify 遍历 Watcher 数组执行每一个 Watcher 的 update >  update 里面最后执行实例化 Watcher 时传入的 callback

observe(obj)

// 重点在于，Watcher 是全局实例的 ，Dep.target是 vue 全局唯一的
// 先 new 内部把 Dep.target 赋值为 当前的实例 Watcher
new Watcher(obj, 'a.b.c', (val) => {
  // 最后在回调函数里，发现，其实和 组件内的 watch 作用是一样的
  // 值改变时，起到一个监听的作用，在函数里做些事情比如 推入nextTick去异步更新视图
  // 这就是得到的值 99
  console.log(val)
})

obj.a.b.c = 99

console.log(obj)
```







