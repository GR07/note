# 收集依赖（订阅） 与 派发更新（发布）


# 为什么要收集依赖？

在前面数据劫持的基础上，如果要更新视图，只要在 setter 中调用一下渲染函数来重新渲染页面，不就能完成在数据变化时更新页面了

答：确实可以，但是这样做的代价就是，任何一个数据的变化，都会导致这个页面的重新渲染。

答：我们想做的效果是：数据变化时，只更新与这个数据有关的 DOM 结构，所以需要收集依赖。 



# 什么是依赖？

举个例子：现在淘宝某店铺上有一块显卡处于预售阶段，如果我们想买的话，可以点击预售提醒，当显卡开始卖的时候，淘宝为我们推送一条消息，我们看到消息后，可以开始购买。


# 发布-订阅模式

- 以上淘宝例子抽象一下就是，发布-订阅模式

买家点击预售提醒，就相当于在淘宝上登记了自己的信息(订阅)，淘宝将买家的信息保存在一个数组中。显卡正式开放购买时，淘宝会遍历数组通知所有的买家：显卡开卖了(发布)，买家收到通知进行一些动作(更新视图)。


- 在 Vue 响应式系统中，显卡指的是数据，买家指的是一个抽象的类 Watcher。

- 每个 Watcher 实例可以订阅一个或者多个数据，这些数据也被称为 wacther 的依赖。

- 当依赖发生变化，Watcher 实例会接收到数据发生变化这条消息，之后 Watcher 内部会执行一个回调函数来实现某些功能，比如更新页面。





- vue1.x，细颗粒度依赖，只要用到数据的 DOM，都是依赖

- vue2.x，中颗粒度依赖，只有用到数据的 组件级别，才是依赖（所以 vue2 ，当一个 abc props 传给组件，只要abc改变，整个组件都会重新渲染（渲染函数-AST-VDOM））


如何收集依赖？

- 在 getter 中收集这些依赖，在 setter 中循环触发收集的依赖。

因为只要用到这个数据，就会触发 getter，所以谁触发的 getter 就把谁收集起来。


- 实现步骤

1. 把依赖收集的代码封装成一个 Dep 类（依赖的缩写dependence）专门用来管理依赖，每个 Observer 实例中都有一个 Dep 实例。
  - Dep 使用发布订阅模式，数据发生变化，则会循环 依赖列表（Watcher数组），挨个通知。


2. Watcher 是一个中介

  - getter 时，调用 dep.depend() 收集依赖（依赖就是 Watcher）
    哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中

  - setter 时，调用 dep.notify() 触发通知（通知的也是 Watcher）






```js
// Dep 是发布订阅模式
// 其实传入对象里面的每一个对象都会有一个 Dep 实例
// Dep.js
let uid = 0
export default class Dep {
  constructor () {
    this.id = uid ++
    // 用数组存储自己的订阅者（也就是 new Watcher() 实例）
    // subscribes 订阅者的意思
    this.subs = []
  }
  // 添加订阅（Watcher实例）
  addSub(sub) {
    this.subs.push(sub)
  }
  // 用于调用添加订阅
  depend () {
    // target 是全局一个指定的位置，用于存当前数据的 Watcher 实例
    // getter 函数中，从 Dep.target 中拿到当前数据的 watcher
    if (Dep.target) {
      this.addSub(Dep.target)
    }
  }
  // 通知更新（通知每一个Watcher实例）
  notify () {
    // 拷贝一份
    const subs = this.subs.slice()
    for (let i = 0, len = subs.length; i < len; i ++) {
      subs[i].update()
    }
  }
}

export default class Observer {
  // 构造器
  constructor(value) {
    // 每层的对象数据上 __ob__ 都有一个 Observer，每个 Observer 里面又有一个Dep
    // 这里的实例化，是为了把 Dep 绑定到 Observer 上面
    this.dep = new Dep()

    def(value, '__ob__', this, false);
    
    if (Array.isArray(value)) {
      // 
    } else {
      // 
    }
  }
}


export default function defineReactive(data, key, value) {
  const dep = new Dep()
  // 经过 Observer 构造函数 walk 遍历过的，赋值给闭包
  if (arguments.length === 2) {
    value = data[key];
  }
  
  let childOb = observe(value)
  
  Object.defineProperty(data, key, {
    // 可枚举 可以for-in
    enumerable: true,
    // 可被配置，比如可以被delete
    configurable: true,
    // getter
    get() {
      // 如果存在 watcher 实例 则收集到数组
      if (Dep.target) {
        dep.depend()
        // 如果有子对象，这里才是将子对象的watcher加入数组 
        if (childOb) {
          // childOb 就是 Observer 实例，所以内部也会有一个 Dep 实例
          childOb.dep.depend()
        }
      }
      return value;
    },
    // setter
    set(newValue) {
      if (value === newValue) return;
      value = newValue;
      
      childOb = observe(newValue)

      dep.notify()
    },
  });
}


methodsNeedChange.forEach(methodName => {
  
  def(arrayMethods, methodName, function () {
    
    if (inserted) {
      // 则使用 Observer 的实例方法 observeArray 再去遍历执行 observe
      ob.observeArray(inserted)
    }
    // 数组改变时，也要去触发 notify
    ob.dep.notify()

    return result
  }, false)
})


// 用于获取 let val = a.b.c 表达式的 值
export function parsePath (path: string): any {
  // a.b.c.d
  const segments = path.split('.')
  return function (obj) {
    // 一层一层拿到属性 a.b.c.d
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}


export default class Watcher {
  // target 传入的当前数据对象
  // 字符串表达式 a.b.c
  // 回调函数，值改变时需要做的事情。
  constructor (target, expression, callback) {
    this.id = uid ++
    this.target = target
    // parsePath 函数 等待调用，然后获取到值
    this.getter = parsePath(expression)
    this.callback = callback
    this.value = this.get()
  }
  update () {
    this.run()
  }
  get () {
    // 全局的 target = 当前watcher实例
    Dep.target = this
    const obj = this.target
    let value
    try {
      // 获取到值
      value = this.getter(obj)
    } finally {
      Dep.target = null
    }

    return value
  }
  run () {
    this.getAndInvoke(this.callback)
  }
  getAndInvoke (cb) {
    const value = this.get()

    if (value !== this.value || typeof value === 'object') {
      const oldValue = this.value
      this.value = value
      cb.call(this.target, value, oldValue)
    }
  }
}


// 总结过程

// 先 observe > 然后实例 Watcher 所以 Dep.target 就存在了 > 数据改变 > 触发 getter 收集全局 Dep.target > 触发 setter 执行 notify 遍历 Watcher 数组执行每一个 Watcher 的 update >  update 里面最后执行实例化 Watcher 时传入的 callback

observe(obj)

// 重点在于，Watcher 是全局实例的 ，Dep.target是 vue 全局唯一的
// 先 new 内部把 Dep.target 赋值为 当前的实例 Watcher
new Watcher(obj, 'a.b.c', (val) => {
  // 最后在回调函数里，发现，其实和 组件内的 watch 作用是一样的
  // 值改变时，起到一个监听的作用，在函数里做些事情比如 推入nextTick去异步更新视图
  // 这就是得到的值 99
  console.log(val)
})

obj.a.b.c = 99

console.log(obj)
```


