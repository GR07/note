# js 执行机制 Event loop

单线程同一时间只能做一件事，为了解决这个问题，JS 的设计者将所有任务分为两种：同步任务和异步任务

浏览器会按照顺序将同步任务一个一个放进主线程中，都在主线程上排队执行，前面任务没有执行完成，后面的任务会一直等待；

异步任务则是挂在在一个任务队列里，等待主线程所有同步代码执行完成后，将事件队列中的任务按照先进先出的顺序添加到主线程中执行。

因为 js 是单线程，所以无论同步异步，js 代码最终都是在主线程上执行的。



# 异步任务被分为两类


+ 微任务（micro task）

由js引擎发起的任务

Promise.then | catch | finally / MutationObserver（仅在浏览器环境） / Object.obverse / process.nextTick（仅在 Node 环境）


+ 宏任务（macro task）

由宿主对象发起的任务

script整体代码 / setTimeout（最小时间延迟是4ms） / setInterval / I/O（键盘、网络） / UI rending / setImmediate（仅在 Node 环境）




# 事件执行顺序


先执行主线程（也就是同步代码）

执行完主线程后，看微任务队列有没有可执行的有的话直接加入主线程执行，没有的话进入下一次事件循环，下一次事件循环一开始，如果有在等待的宏任务（setTimeout）则加入主线程执行，如果没有，进行下一次事件循环。


- 注意：new promise() 里面的是同步代码，then里面才是微任务异步代码
```js
new Promise(function (resolve) {
  // 同步代码
  console.log(3)    
  for (var i = 100; i > 0; i--) {
    i == 1 && resolve()
  }
  console.log(4)
}).then(function () {
  // 微任务异步代码
  console.log(5)
})
```


# 总结

1. 整体 script 作为第一个宏任务开始执行，此时会把所有代码分为“同步任务”和“异步任务”两部分

2. 同步任务直接进入主线程依次执行

3. 异步任务再分为宏任务和微任务

4. 当主线程的任务执行完毕，主线程为空，此时会检查微任务的任务队列，如果有微任务，不管多少个都全部执行完，没有就进入下一次循环，循环一开始就执行下一个宏任务，再检查微任务，没有就进入下一次循环

5. 上述过程不断重复，这就是事件循环（Event Loop）

6. 浏览器会在当前宏任务结束之后，下一个宏任务执行开始之前（也就是一次事件循环内），对页面进行重新GUI渲染（宏任务 > 渲染 > 宏任务 > ...）

7.  一个事件循环内 只会执行一个宏任务 + 多个微任务（有多少执行多少）

8. 异步任务队列是先进先出的集合