# 为什么需要模块化

抽象 / 复用 / 封装 / 依赖管理

历史上，JavaScript 一直没有模块体系（module），无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。这对开发大型的、复杂的项目形成了巨大障碍。

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS（用于服务器） 和 AMD（用于浏览器）

现在 ES6 module 完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。




# CommonJs

- 代表库为 node.js 早期

- CommonJs 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。

- 导出时是值拷贝，就算导出的值变了，导入的值也不会改变。

- 只能在运行时确定模块依赖关系以及输入和输出的变量，称为运行时加载，导致完全没办法在编译时做 “静态分析优化”

```js
// a.js
module.exports={ foo , bar}

// b.js
const { foo, bar } = require('./a.js')

// 上面 require 其实是整体加载了 a.js 模块的所有代码进来，然后再从 fs 模块读取 2个 方法，等同于下面
const a = require('./a.js')
let stat = a.stat;
let exists = a.exists;

```


# ES6 Module 

- 是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对 页面渲染有很大影响。

- 导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。

- ES6 模块的设计思想是尽量的静态化，在编译时就能确定模块的依赖关系，以及输入和输出的变量。

- 因为是编译时加载，使得静态分析成为可能。有了它就能引入类型检验，这种只能靠静态分析实现。

- export / import 命令只要处于模块最外层作用域即可，会自动提升到整个模块的头部。如果处于块级作用域内，就会报错，这是因为处于条件代码块之中需要运行时才知道，也就无法做静态分析了。（ES2020提案可以支持）

- 多次重复执行同一句import语句，那么只会执行一次

```js
// ES6 module 的实质是从 a.js 模块只加载 2 个方法，其他方法不加载，称为 “编译时加载”，效率要比 CommonJS 模块的加载方式高

import { foo, bar } from './a.js';
```



# import() 函数

ES2020提案 引入 import() 函数，支持动态加载模块。(支持可以在运行时确定模块依赖关系)

新功能允许将 import() 作为函数调用，模块的路径作为参数传递，返回一个 promise。

```js
import('/modules/myModule.mjs').then((module) => {});
```



# 最后

- ES6 module 被认为是 “未来”，但 CommonJS 仍然在社区和生态系统中占有重要地位。

- esm 对打包工具来说更容易正确地进行 treeshaking，因此对于库来说，拥有这种格式很重要。

- 或许在将来的某一天，你的库只需要输出 esm。


目前，通过 Babel 转码，CommonJS 模块的 require 语法和 ES6 模块的 import 语法，可以写在同一个模块里面，但是最好不要这样做。因为 import 在静态解析阶段执行，所以它是一个模块之中最早执行的。