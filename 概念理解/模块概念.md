# 为什么需要模块化

抽象 / 复用 / 封装 / 依赖管理

历史上，JavaScript 一直没有模块体系（module），无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。这对开发大型的、复杂的项目形成了巨大障碍。

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS（用于服务器） 和 AMD（用于浏览器）

现在 ES6 module 完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。




# CommonJs

- 代表库为 node.js 早期

- CommonJs 是同步导入，设计初衷是用于服务端，因为本地文件的 IO 很快，同步导入即使卡住主线程影响也不大。但是同步的方式运用到浏览器就不友好了，因为在浏览器中模块文件都是通过网络加载的，单线程阻塞在模块加载上，这是不可接受的

- 导出时是值拷贝，就算导出的值变了，导入的值也不会改变。

- 只能在运行时确定模块依赖关系以及输入和输出的变量，称为运行时加载，导致完全没办法在编译时做 “静态分析优化”

```js
// a.js
module.exports = { foo , bar}

// b.js
const { foo, bar } = require('./a.js')

// 上面 require 其实是整体加载了 a.js 模块的所有代码进来，然后再从 fs 模块读取 2个 方法，等同于下面
const a = require('./a.js')
let stat = a.stat;
let exists = a.exists;


// lib.js
module.exports.add = function add() {};

// main.js
const { add } = require("./lib.js");
add();
```

# AMD

 - CommonJs 是同步导入，但是同步的方式运用到浏览器就不友好了，因为在浏览器中模块文件都是通过网络加载的，单线程阻塞在模块加载上，这是不可接受的，所以 在 2011 年有人提出了 AMD，对 CommonJS 兼容的同时支持异步加载。

- AMD 的特征是使用 define(deps, callback) 来异步加载模块。

```JS
define(['dep1', 'dep2'], function (dep1, dep2) {
    return function () {};
});
```


# UMD

因为 CommonJS 和 AMD 的流行，随后又有人提出了 UMD 的模块标准，UMD 通过对不同的环境特性进行检测，对 AMD、CommonJS 和 Global Variable 三种格式兼容。

- UMD 的兼容性好，不少库都会提供 UMD 的版本。

```js
// UMD
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['jquery', 'underscore'], factory);
  } else if (typeof exports === 'object') {
    // Node, CommonJS-like
    module.exports = factory(require('jquery'), require('underscore'));
  } else {
    // Browser globals (root is window)
    root.returnExports = factory(root.jQuery, root._);
  }
}(this, function ($, _) {
  //    methods
  function a(){};    //    private because it's not returned (see below)
  function b(){};    //    public because it's returned
  function c(){};    //    public because it's returned
  //    exposed public methods
  return {
    b: b,
    c: c
  }
}));
```



# ES Module 

在 2015 年发布了 ES6（ES 2015），在这次版本更新中，制定了 JS 模块标准即 ES Modules，ES Modules 使用 import 声明依赖，export 声明接口。

- 在 HTML 中通过为 script 标签添加 type="module" 属性来声明 ESM 类型

  1. 默认启用严格模式即 "use strict"；
  2. 默认 defer 加载执行；
  3. 默认启用 CORS 跨域；
  4. 在同一个文档中，相同的模块只会加载、执行一次；

```js
// module.js
export default function test(){
  return 'test...'
}

// index.js
import test from './module.js';
console.log(test())
```
```html
<body>
  // 方法 1 ： 引入module.js，然后在script标签里面调用
  <script type="module">
    import test from './module.js';
    console.log(test())
  </script>
 
  // 方法 2 ： 直接引入index.js，使用src引入
  <script type="module" src="./index.js"></script>
 
</body>
```

- 是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对 页面渲染有很大影响。

- 导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。

- ES6 模块的设计思想是尽量的静态化，在编译时就能确定模块的依赖关系，以及输入和输出的变量。

- 因为是编译时加载，使得静态分析成为可能。有了它就能引入类型检验，这种只能靠静态分析实现。

- export / import 命令只要处于模块最外层作用域即可，会自动提升到整个模块的头部。如果处于块级作用域内，就会报错，这是因为处于条件代码块之中需要运行时才知道，也就无法做静态分析了。（ES2020提案可以支持）

- 多次重复执行同一句import语句，那么只会执行一次

```js
// ES6 module 的实质是从 a.js 模块只加载 2 个方法，其他方法不加载，称为 “编译时加载”，效率要比 CommonJS 模块的加载方式高

import { foo, bar } from './a.js';
```



# import() 函数

ES2020提案 引入 import() 函数，支持动态加载模块。(支持可以在运行时确定模块依赖关系)

新功能允许将 import() 作为函数调用，模块的路径作为参数传递，返回一个 promise。

```js
import('/modules/myModule.mjs').then((module) => {});
```





# CommonJS 和 ES Module 混用

因为历史原因，npm 上大多数的包都使用 CJS 编写，但是随着 ESM 的出现，开发者们开始使用 ESM 去编写模块。而为了最大程度复用 npm 上的包，在 ESM 中难免会需要导入 CJS。而因为模块加载方式的差异性，CJS 无法导入 ESM，而 ESM 可以导入 CJS。

- 混用但必须 CommonJS 使用默认的导入导出
```js
// correct.cjs
exports.a = 1;
exports.b = 2;
if (Math.random() > 0.5) {
  exports.c = 3;
}

// main.mjs
import { a, b, c } from './correct.cjs';
// 执行 main.mjs 无异常
```

- 否则报错
```js
// wrong.cjs
// 使用 tmp 来设置 exports
const tmp = exports;
tmp.a = 1;
tmp.b = 2;
if (Math.random() > 0.5) {
  tmp.c = 3;
}

// main.mjs
import { a, b, c } from './wrong.cjs';
// 执行 main.mjs 报错
```

- 兼容处理

```js
// lib.cjs
const tmp = exports;
tmp.a = 1;
tmp.b = 2;
if (Math.random() > 0.5) {
  tmp.c = 3;
}

// lib-esm-wrapper.mjs
// 封装一层代码，对 CJS 采用 default import，然后对里面指定的变量 re-export 一次
import lib from "./lib.cjs";
export const { a, b, c } = lib;

// main.mjs
import { a, b, c } from "./lib-esm-wrapper.mjs";
console.log(a);
console.log(b);
console.log(c);
```



# 最后


- ES6 module 被认为是 “未来”，但 CommonJS 仍然在社区和生态系统中占有重要地位。

- esm 对打包工具来说更容易正确地进行 treeshaking，因此对于库来说，拥有这种格式很重要。

- 或许在将来的某一天，你的库只需要输出 esm。

- 现在仍然在使用的模块标准主要就是 CJS 和 ESM，CJS 的存在主要是 Node 的历史原因。



# 如何编写支持多种模块格式的库

有时候我们在编写库的时候，希望我们的库支持 CJS 和 ESM 两种格式，大家可能对 package.json 的 module 字段比较熟悉，它是一个约定俗成的字段，主要用在 Module Bundler 如 Webpack、Rollup 对包是否支持 ESM 的检查，然而 Node 并不会对该字段识别。

在 Node 12+ 我们可以使用 package.json 的 exports 字段来为包配置支持不同的模块文件，Node 会根据你使用 import 还是 require 来加载，返回相应的模块文件：
```js
// package.json
{
  "exports": {
   	"import": "./lib.mjs",
    "require": "./lib.cjs" 
  }
}

// app.mjs
import { value } from "lib";
console.log("value from mjs", value);

// app.cjs
const value = require("lib").value;
console.log("value from cjs", value);
```