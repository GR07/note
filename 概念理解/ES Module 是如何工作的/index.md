# ESM 是什么

为 JS 带来了一个正式的、规范化的模块系统，很少有 JS 开发者真正理解 ESM 是如何工作的。


# ESM 是如何工作的

ESM 在工作过程中，一共需要三大阶段：

1. 构建
2. 实例化
3. 计算

# 构建（Construction）

当你在使用模块化进行开发时，你将会构建一个依赖关系图，不同依赖项之间的连接来自于导入语句。

这些导入语句让浏览器和 Node 知道需要加载哪些代码，你给它们一个文件的地址，它们去追踪这些文件。

但是文件本身浏览器是无法直接用的，因此还需要解析这些文件，将它们转换为称之为（Module Record 模块记录）的数据结构。这样，它们就知道文件中发生了什么。


在构建阶段，每个模块会发生三件事情

- 弄清楚从哪里下载模块文件（又称为模块解析）

loader 负责查找文件和下载文件，首先需要找到入口文件，在 HTML 中通过 <script src=""></script>来告诉浏览器文件在哪里。

# 如何构建依赖关系图？

import 语句的一部分称为模块说明符，他告诉 loader 在哪里可以找到下一个模块。需要一层一层的遍历树，解析一个文件，然后找出它的依赖项，然后查找文件并下载




这种将算法分割为多个阶段的方法就是 ESM 和 CJS 的主要区别之一。


- 获取文件（从 URL 下载或者从文件系统加载）
- 将文件解析为模块记录







- 实例化（Instantiation）：将导出的变量指向内存中（但是不会填充值），然后将导出和导入指向这个内存，这就是所谓的链接（Linking）。

之后，将模块记录转换为模块实例，一个实例兼备两件事情：代码和状态。

代码基本是一组指令的集合。

状态是变量在任何时间点的实际值，也就是保存在内存中的值。

因此，模块实例将 代码（指令列表） 和 状态（所有变量的值） 组合在一起。

所以在加载这个模块的时候，就从一个文件变成了一个模块实例。

![本地路径](Snipaste_2024-04-15_23-09-11.png)


- 计算（Evaluation）：运行代码，用实际的值来填充到内存中

运行代码，用实际的值来填充到内存中


# 为什么说是异步的

我们都说 ES 模块是异步的，你可以把它看作是异步的，因为工作被分为了三个阶段——构建、实例化、计算。这些阶段可以分别完成。如果主线程一直在等待下载文件，那么将会线程阻塞。这是因为在浏览器运行中，下载需要耗费很长一段时间。这样阻塞主线程就导致程序会运行的很慢。这也是 ESM 将算法分为多个阶段的原因。

而 CJS 则不是异步的，因此在 CJS 规范中，一个模块和它的依赖关系是一次性构建、实例化和计算的，中间没有任何间断。


# 为什么模块标识符（from './xx'）不可以是变量

在 CJS 中的 require 的模块标识符中，可以使用变量。这是因为在寻找下一个模块之前，该模块就已经执行了除了 require 之外的所有代码，因此在执行模块解析的过程中，变量是有值的

但是在使用 ESM 时，在进行任何计算阶段之前，需要先构建出整个模块图。这就意味着不能在模块标识符中存在任何变量，因为这些变量还没有值。

为了让 ESM 做到这一点，有一个动态导入的提议。import(`${path}/foo.js`)