
# 如何选择

如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。

如果你需要进行简单的遍历，用 forEach 或者 for of。

如果你需要对迭代器进行遍历，用 for of。

如果你需要过滤出符合条件的项，用 filterr。

如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter。



# forEach()

常用于对数组自身的改变和各元素相关统计性的计算

返回undefined / 中途不能跳出循环

item如果是值类型，原数组不可改变，如果是引用类型则可以改变



# map()

item如果是值类型，原数组不可改变，如果是引用类型则可以改变（map的思想是 不修改原数组返回一个新数组，所以最好不要用map修改原数组。）

返回一个新数组 / 中途不能跳出循环

每一项 item 是调用函数返回的结果



# for (let item of arr) {}

常用于数组，支持解构。（特性：对迭代器进行遍历）



# filter()

返回一个新数组

每一项 item 是调用函数筛选出来符合条件的结果




# sort()

直接改变原数组

```js
// 默认排序:
[10, 20, 1, 2].sort();  [1, 10, 2, 20]

// 自定义
arr.sort((x, y) => {
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
});
[1, 2, 10, 20]
```



# some()

返回布尔值

数组只要有一项满足即返回 true，之后的不再执行(所以说对性能很友好！)。

注：当内部 return true 时跳出整个循环



# every()

数组中的每一项只有都满足了才会返回 true
注：当内部 return false 时跳出整个循环



# 获取数组中指定元素

find()  返回第一个匹配到的元素本身
findIndex()  返回索引

虽然 filter() 确实可以做到 但是会从头遍历到尾 出于性能的考虑 find() 可以找到匹配项就终止

```js
let testArr = [{name:'鸣人',age:16},{name:'佐助',age:17},{name:'卡卡西',age:27},{name:'佐助',age:17}]
let result = testArr.find(item => { return item.name == '佐助'}); // { name:'佐助',age:17 }

```


# includes()

返回布尔值表示某个数组是否包含给定的值

indexOf()它会返回 -1 和元素的位置来表示包含的意思 不够语义化 也不能判断是否包含NaN元素

