<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>原型上下文系列</title>
  <style>

    原型上下文系列：



    /*每个函数都有 prototype 属性，值是一个对象,默认的只有一个叫做constructor的属性，值指向这个函数本身。

    每个对象都有 __proto__ 属性，指向创建该对象的函数的prototype。*/



    /*执行上下文：

    变量、函数表达式——变量声明，默认赋值为undefined；
    this——赋值；
    函数声明——赋值；

    这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”

    函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域

    作用域在函数定义时就已经确定了。而不是在函数调用时确定。

    只有当函数执行完毕 这个函数才会被出栈销毁 否则一直在栈中占用内存。

    从始至终只会有一个上下文环境处于活动状态。

    变量取值要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记 这就是----作用域链*/



    /*自执行函数

    1. js中没有块级作用域，用来隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。

    2. 利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理。*/



    /*闭包：只有两种应用场景：
          1.函数的返回值是一个函数
          2.函数当做参数被调用

          综合以上2种情况时内层函数需要用到外层函数的时候 形成闭包

          如果内部函数还未被销毁，那么外部函数中的局部变量会一直存在。（所以这就用到了自执行函数来释放内存）

    闭包只能取得外面函数中所有变量的最后一个值。闭包所保存的是整个变量对象

    变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。*/




    /*执行顺序：同步 => 异步 => 回调

    for循环setTimeout中let本质上就是形成了一个闭包。

    对象内部的函数表达式的内部访问不到对象内的变量*/




  </style>
</head>
<body>
  
</body>
</html>