#### 创建正则表达式

1.表达式字面量
```js
let pattern = /.at/g ;
```

2.构造函数
```js
let re = new RegExp(".at", "g");
```

#### 两者区别

字面量会始终共享一个RegExp实例

构造函数创建的每一个实例都是一个新实例



#### RegExp实例方法

###### exec()

返回匹配项的信息
```js
let text = "cat,bat,sat,fat";
let pattern1 = /.at/;

let matches = pattern1.exec(text);
console.log(matches.index);//0
console.log(matches[0]);//cat
console.log(pattern1.lastIndex);//0

```

##### test()

返回布尔值 判断目标字符串是否与正则匹配
```js
let reg = xxx;

let str = x;

reg.test(str) // true

```


#### 什么是元字符

正则里的元字符大致分为两种：

1.用来匹配文本 例如 .

2.正则语法要求 例如 []

注：如果正则里用到元字符，必须使用 \ 进行转义


```js
// . 匹配任意一个单个的字符

// c.t 匹配结果 cat c2t



// [ ] 匹配一组字符

// 匹配结果是能够与该集合里的任意一个成员相匹配的文本

// [nN]可以匹配的是 n或者N



// - 集合区间

// [0-9] 匹配结果 [012346789]



// ^ 取非匹配 （也可以用来定义字符串的开始，$用来定义字符串的结束）

// ^表明对一个字符集合[] 进行取非匹配

// [^0-9] 匹配结果 除了0-9的其他字符都匹配



// \d 任意一个数字 等价于 [0-9]


// \D 任意一个非数字 等价于 [^0-9]


// \w 任意一个 字母、数字、下划线 等价于 [0-9a-zA-z_]


// \W 任意一个非 字母、数字、下划线 等价于 [^0-9a-zA-z_]


// \s 任意一个 空白字符 等价于 [\f\n\r\t\v]


// \S 任意一个非 空白字符 等价于 [^\f\n\r\t\v]


// + 重复匹配一个或多个 可以匹配一个字符或字符集[] 的一次或多次重复出现

// [\w.]+ 结果： 将匹配一个或多个 （字母数字字符、下划线和.）的一次或多次重复出现


// * 重复匹配零个或多个 可以匹配一个字符或字符集[] 的零次或多次重复出现


// ? 只能匹配出现零次或一次的字符或字符集合[] 不能超过一次


// {} 精准匹配重复次数 

// 例如 [0-5]{2} 匹配结果：0-5之间的数字重复2次 即可以匹配01 02 03 04 05 一直到55 之间的任意数字



// {n, m} n为匹配的最少次数，m为最多次数

// 例如 \d{1,3} 匹配1个到3个数字字符



// {n,} 最少匹配次数 无上限

// 例如 \d{3,} 至少匹配3个数字



// () 子表达式

// DOB:1967-08-17 

// (19|20)\d{2} 结果 1967




// \1 是回溯匹配 表示引用前面的第一个匹配结果




// ?= 从开始匹配的位置 向前查找 需要匹配的文本在 = 后面

// http://www.vicky.com
// .+(?=:) 匹配结果 http

// 只要找到：就行了，不要把它包括在最终的匹配结果里



```