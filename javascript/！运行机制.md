# 单线程

作为浏览器的脚本语言，因此 JS 注定是单线程。

单线程同一时间只能做一件事，为了解决这个问题，JS 的设计者将所有任务分为两种：同步任务（synchronous）和异步任务（asynchronous）



# 同步任务和异步任务

同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务

异步任务：不进入主线程，而是加入任务队列（task queue），只有任务队列通知主线程，该任务才会加入主线程执行




# 异步任务被分为两类


+ 微任务（micro task）

Promise.then | catch | finally / process.nextTick（仅在 Node 环境） / MutationObserver（仅在浏览器环境）


+ 宏任务（macro task）

script / setTimeout（最小时间延迟是4ms） / setInterval / setImmediate（仅在 Node 环境）/ I/O / requestAnimationFrame（仅在浏览器环境）






# 事件执行顺序


先执行主线程（也就是同步代码）

再执行所有微任务（promise.then）

最后执行回调（setTimeout）

同步任务异步任务都需要在主线程执行栈中执行


执行完主线程后，看看微任务队列有的话直接加入主线程执行，没有的话进入下一次事件循环，下一次事件循环一开始，如果有在等待的宏任务（setTimeout）则加入主线程执行，如果没有，进行下一次事件循环。



# 简单例子

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");

```

setTimeout 是一个宏任务，回调函数会在下次事件循环前执行。

then 会通过微任务队列，在当前事件循环之后执行。

alert 首先显示，因为它是常规的同步调用。




# 任务队列

队列是先进先出的集合

浏览器的event loop至少包含两个队列，宏任务队列和微任务队列



# 总结

1. 整体 script 作为第一个宏任务开始执行，此时会把所有代码分为“同步任务”和“异步任务”两部分

2. 同步任务直接进入主线程依次执行

3. 异步任务再分为宏任务和微任务

4. 宏任务进入事件列表中，并在里面注册回调函数，每当指定的事件完成时，事件列表会将这个函数移到任务队列中

5. 微任务也会进入另一个事件列表，并执行第 4 步一样的操作

6. 当主线程的任务执行完毕，主线程为空，此时会检查微任务的任务队列，如果有任务，就全部执行，没有就执行下一个宏任务

7. 上述过程不断重复，这就是事件循环（Event Loop）