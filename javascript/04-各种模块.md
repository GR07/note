# 为什么需要模块化

抽象 / 复用 / 封装 / 依赖管理

历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。这对开发大型的、复杂的项目形成了巨大障碍。


在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。

现在 ES6 module 完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。


# 何时确定模块的依赖关系

- ES6 模块的设计思想是尽量的静态化，在编译时就能确定模块的依赖关系，以及输入和输出的变量。

- CommonJS 和 AMD 模块，都只能在运行时确定这些东西。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。


- 举例子

下面的代码
```js
// require 其实是整体加载了 fs 模块的所有代码进来

// 然后再从 fs 模块读取 3个 方法

let { stat, exists, readfile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```

```js
// ES6 module 的实质是从 fs 模块只加载 3 个方法，其他方法不加载。

// 这种加载称为 “编译时加载” 或者静态加载

// 即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。

import { stat, exists, readFile } from 'fs'; // 如果不带有路径，必须通过配置，告诉引擎怎么取到这个模块。
```


# 动静态的值

ES6 module 可以取到模块内部实时的值。


CommonJS 模块输出的是值的缓存，不存在动态更新。


# CommonJs

代表库为node.js早期

CommonJs 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。

导出时是值拷贝，就算导出的值变了，导入的值也不会改变。

只能在运行时确定模块依赖关系以及输入和输出的变量。

```js
// a.js
module.exports={ foo , bar}
// b.js
const { foo,bar } = require('./a.js')
```




# Module 

是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对 页面渲染有很大影响。

导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。

由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。

export、import 命令只要处于模块最外层作用域就可以。如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。

import命令具有提升效果，会提升到整个模块的头部，首先执行。

由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。

如果多次重复执行同一句import语句，那么只会执行一次



目前阶段，通过 Babel 转码，CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。

```js
require('core-js/modules/es6.symbol');
require('core-js/modules/es6.promise');
import React from 'React';
```


# 动态加载

ES2020提案 引入import()函数，支持动态加载模块。(支持可以在运行时确定模块依赖关系)

新功能允许将import()作为函数调用，模块的路径作为参数传递，返回一个 promise。

```js
import('/modules/myModule.mjs').then((module) => {});
```