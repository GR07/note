既然我们要优化webpack打包，肯定要提前对我们的bundle文件进行分析，分析各模块的大小，以及分析打包时间的耗时主要是在哪里

# 主要用到两个 webpack 插件

- speed-measure-webpack-plugin 用于测速

- webpack-bundle-analyzer 用于分析 bundle 文件


```js
// 用于测速
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin")
// 用于分析 bundle 文件
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
const smp = new SpeedMeasurePlugin({
  outputFormat:"human",
});
module.exports = {
// 需要用 smp 对配置进行再包裹，SpeedMeasurePlugin 会对你的其他 Plugin 对象包裹一层代理，这样的目的是为了能够知道 plugin 开始和结束的时间
configureWebpack: smp.wrap({
    plugins: [
      new webpack.ProvidePlugin({
        $: "zepto",
        Zepto: "zepto",
      }),
      // BundleAnalyzerPlugin 就跟普通的 plugin 一样，放在 plugins 数组的后面即可
      new BundleAnalyzerPlugin(),
    ],
    optimization: {
      splitChunks: {
        cacheGroups: {
          echarts: {
            name: "chunk-echarts",
            test: /[\\/]node_modules[\\/]echarts[\\/]/,
            chunks: "all",
            priority: 10,
            reuseExistingChunk: true,
            enforce: true,
          },
          demo: {
            name: "chunk-demo",
            test: /[\\/]src[\\/]views[\\/]demo[\\/]/,
            chunks: "all",
            priority: 20,
            reuseExistingChunk: true,
            enforce: true,
          },
          page: {
            name: "chunk-page",
            test: /[\\/]src[\\/]/,
            chunks: "all",
            priority: 10,
            reuseExistingChunk: true,
            enforce: true,
          },
          vendors: {
            name: "chunk-vendors",
            test: /[\\/]node_modules[\\/]/,
            chunks: "all",
            priority: 5,
            reuseExistingChunk: true,
            enforce: true,
          },
        },
      },
    },
  })
}
```



# 通过以下命令行查看你现有的配置文件是怎样的

npx vue-cli-service inspect > output.js


# 更改 vuecli 配置

参考 vue-cli 的官方文档
configureWebpack
Type: Object | Function
如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。
如果这个值是一个函数，则会接收被解析的配置作为参数。该函数及可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。