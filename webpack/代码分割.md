# 为什么要分割代码

为了降低包体积，常会把存在多个路由的项目的每个页面都单独打一个包，只有访问某个页面的时候，再去下载该页面的js包，以此来加快首页的渲染。


# webpack 三种常见代码分割方式

- 入口起点：在 entry 配置多个入口文件手动分离代码。（每个入口文件一定会独立打包）

- 动态导入：通过模块的内联函数调用来分离代码。（使用 import()）

- 防止重复：使用 splitChunks 去重和分离 chunk。（webpack 将满足规则的 chunk 自动分离。）



# splitChunks 默认配置

总结：下面的默认配置满足以下四种条件会打包

- 模块在代码中被复用或者来自 node_modules 文件夹

- 模块的体积大于等于30kb（压缩之前）

- 当按需加载当前 chunks 时，chunks 内的按需加载文件不能超过 4，所以称为并行请求文件的最大数量不能超过 5。

- 页面初始加载时，并行请求的最大数量不能超过3

```js
splitChunks: {
    // 表示选择哪些 chunks 进行分割，可选值有：async，initial和all
    chunks: "async",
    // 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。
    minSize: 30000,
    // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。
    minChunks: 1,
    // 表示按需加载文件时，并行请求的最大数目。默认为5。
    maxAsyncRequests: 5,
    // 表示加载入口文件时，并行请求的最大数目。默认为3。
    maxInitialRequests: 3,
    // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js
    automaticNameDelimiter: '~',
    // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。
    name: true,
    // cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据 priority 来决定打包到哪个组中。
    cacheGroups: {
        // 默认将所有来自 node_modules 目录的模块打包至 vendors 组
        vendors: {
            test: /[\\/]node_modules[\\/]/,
            priority: -10
        },
        // 默认将两个以上的 chunk 所共享的模块打包至 default 组。
        default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true
        }
    }
}
```

# 实际分析

如果是默认配置，以下会被打成 3 个 js 文件

1. index.js 入口文件 会被独立打包(app.js)

2. import("./a") 会被独立打包 (1.js)

3. import "vue"; vue 来自 node_modules 目录，并且大于 30kb；
   将其从 a.js 拆出后，与 a.js 并行加载，并行加载的请求数为2，未超过默认的5；
   vue 拆分后，并行加载的入口文件并无增加，未超过默认的3。
   vue 也符合 splitChunks 的拆分条件，单独打了一个包（2.js）


```js
// index.js 入口文件
// 注意，如果入口文件有引入 node_modules 的包，会被打到 vendors~app.js中，而非入口文件引入 node_modules 的包，会独立命名打包。

import("./a");

```

```js
// a.js

import "vue";

```

# 理解 chunks

当 chunks 值为 initial 时，splitChunks 的作用范围变成了非异步加载的初始 chunk，例如我们的 入口文件 就是初始化的时候就存在的chunk。而 vue 模块是在异步加载的 a.js 中引入的，所以并不会被分离出来。



# 理解 maxInitialRequests