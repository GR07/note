# 减少冗余辅助函数

babel-plugin-transform-runtime 是 Babel 官方提供的一个插件，把辅助函数代码变为 var _extent = require('babel-runtime/helpers/_extent');


# 图片转 base64 编码的字符串直接注入到代码

把图片转 base64 编码的字符串直接注入到代码，减少http请求


# 缩小文件搜索范围 include

Loader 对文件的转换操作很耗时，需要让尽可能少的文件被 Loader 处理。


# resolve.alias 配置路径别名


# 使用 HappyPack 多进程构建 vue-cli不支持

构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。

把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。

注意是 多进程 不支持 多线程


# DllPlugin 动态链接库

将react和react-dom单独打包好，然后动态链接引入即可。如果第二次打包，那么发现react和react-dom已经被打包好了，那么就不需要再打包了，这样就大大提升了性能。




# 模块热更新插件 HotModuleReplacementPlugin

Hot-Module-Replacement 的热更新是依赖于 webpack-dev-server

后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，HMR 是只更新修改的部分。

- HotModuleReplacementPlugin 是 webpack 模块自带的，所以引入 webpack 后，在 plugins 配置项中直接使用即可。

```js
const webpack = require('webpack')

plugins: [
  new webpack.HotModuleReplacementPlugin(), // 热更新插件
]
```


# 生成 html 文件 htmlWebpackPlugin

把打包后的 js 文件 和 extract-text-webpack-plugin 抽取的 css 样式文件，

然后在html-webpack-plugin插件的指定的html模板基础上，插入样式link到head元素中，插入script到head或者body中，最后生成一个 html 文件。

创建了一个全新的 html文件，所有的 bundle 会自动添加到 html 中

解决的问题：当改了打包出口文件名后，可以动态把打包后的文件自动添加到 html 中


```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

plugins: [
  new HtmlWebpackPlugin({
    filename: 'index.html',
    template: path.join(__dirname, '/index.html'),
    minify: {
      // 压缩HTML文件
      removeComments: true, // 移除HTML中的注释
      collapseWhitespace: true, // 删除空白符与换行符
      minifyCSS: true, // 压缩内联css
    },
    // inject 有四个选项值 如下
    inject: true,
  }),
]
// true：默认值，script 标签位于 html 文件的 body 底部
// body：script 标签位于 html 文件的 body 底部（同 true）
// head：script 标签位于 head 标签内
// false：不插入生成的 js 文件，只是单纯的生成一个 html 文件
```

```js
// 多页应用
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  entry: {
    index: './src/index.js',
    login: './src/login.js',
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash:6].js',
  },
  //...
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      filename: 'index.html', //打包后的文件名
      // 这样执行 npm run build，可以看到 index.html 中仅引入了 index 的 js 文件
      chunks: ['index'],
    }),
    new HtmlWebpackPlugin({
      template: './public/login.html',
      filename: 'login.html', //打包后的文件名
      // 这样执行 npm run build，可以看到 index.html 中仅引入了 login 的 js 文件
      chunks: ['login'],
    }),
  ],
}
```


# clean-webpack-plugin

清理 /dist 文件夹

解决的问题：反复打包后，dist目录会有很多历史打包文件，在每次构建前清理 /dist 文件夹。

使用注意：
```js
// 官方文档是错误的示范，需要解构一下，不需传参直接实例化即可。
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
plugins: [
    // clean-wepback-plugin目前已经更新到2.0.0，不需要传参数path
    // cleanStaleWebpackAssets: false 告诉插件删除文件的同时不要删除没有改变的文件
    new CleanWebpackPlugin({ cleanStaleWebpackAssets: false })
]
```


# 分离css文件 插件 mini-css-extract-plugin

不分离的时候，打包后css代码会混合在js代码中
```js
// 例如 color: blue;
___CSS_LOADER_EXPORT___.push([module.i, \"body {\\r\\n    color: blue;\\r\\n}\", \"\"]);
```

使用 npm install --save-dev mini-css-extract-plugin

主要是为了抽离css样式，防止将样式打包在js中引起页面样式加载错乱的现象。



将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 sourceMap。只能用在 webpack4 中

这个插件应该只用在生产环境配置，并且在 loaders 链中不使用 style-loader, 而且这个插件暂时不支持 HotModuleReplacementPlugin(模块热更新插件)

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  module: {
    rules: [
      {
        test: /\.(le|c)ss$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '../',
            },
          },
          'css-loader',
          'postcss-loader',
          'less-loader',
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'css/[name].[contenthash:8].css',
      chunkFilename: 'css/[id].[contenthash:8].css',
    }),
  ],
}
```



# 去除重复 CSS 代码 purifycss-webpack

有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。

```js
const path = require('path')
const PurifyCssWebpack = require('purifycss-webpack') // 引入PurifyCssWebpack插件
const glob = require('glob') // 引入glob模块,用于扫描全部html文件中所引用的css

module.exports = merge(common, {
  plugins: [
    new PurifyCssWebpack({
      paths: glob.sync(path.join(__dirname, 'src/*.html')),
    }),
  ],
})
```


# 压缩 CSS 文件 optimize-css-assets-webpack-plugin

希望减小 css 打包后的体积

```js
const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin") // 压缩css代码

optimization: {
  minimizer: [
    // 压缩css
    new OptimizeCSSAssetsPlugin({})
  ]
}
```



# 压缩 JS 文件 UglifyJsPlugin

uglifyJsPlugin 是 vue-cli 默认使用的压缩代码方式，用来对 js 文件进行压缩，

1. 从而减小 js 文件的大小，加速 load 速度。

2. 也有利于系统代码安全；

3. 清除打印日志和debugger信息

它使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。

配置SplitChunks 抽取公有代码，提升你的应用的性能

从 webpack 4 开始，也可以通过 "mode" 配置选项轻松切换到压缩输出，只需设置为 "production"。

```js
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')

plugins: [
  new UglifyJsPlugin({
    uglifyOptions: {
      compress: {
        warnings: false
      }
    },
    sourceMap: true,  // 是否启用文件缓存
    parallel: true   // 使用多进程并行运行来提高构建速度
  })
]
```


# 压缩 JS 文件 terser-webpack-plugin

Webpack4.0 默认是使用 terser-webpack-plugin 这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel 参数，使用多进程压缩，加快压缩。

```js
const TerserPlugin = require('terser-webpack-plugin') // 压缩js代码

optimization: {
  minimizer: [
    new TerserPlugin({
      parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1
      cache: true, // 是否缓存
      sourceMap: false,
    }),
  ]
}
```



# 为 压缩代码 增加多进程 ParallelUglifyPlugin

开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。

```js
const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')

plugins: [
  new ParallelUglifyPlugin({
    //cacheDir 用于配置缓存存放的目录路径。
    cacheDir: '.cache/',
    sourceMap: true,
    uglifyJS: {
      output: {
        comments: false,
      },
      compress: {
        warnings: false,
      },
    },
  }),
]
```


# gzip 压缩 compression-webpack-plugin

所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。

gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。

当然，这个方法还需要后端配置支持。

```js
const CompressionPlugin = require('compression-webpack-plugin')

plugins: [
  new CompressionPlugin({
    // gzip压缩配置
    test: /\.js$|\.html$|\.css/, // 匹配文件名
    threshold: 10240, // 对超过10kb的数据进行压缩
    deleteOriginalAssets: false, // 是否删除原文件
  }),
]

// 使用异常报错：Cannot read property ‘tapPromise‘ of undefined

// 卸载高版本 npm uninstall compression-webpack-plugin

// 安装低版本 npm i compression-webpack-plugin@5.0.1
```



# 注入环境变量 DefinePlugin

作用：主要是在编译阶段根据 NODE_ENV 自动切换打包配置规则文件，也可在页面中访问环境变量

使用规则：

```js
// 如果是字符串类型，需用双引号或者JSON.stringify()进行引用（因为如果 value 是一个字符串，它将会被当做 code 片段）
'"production"'

JSON.stringify('production')
```

在vue-cli创建的项目中，凡是src下的文件，都可以访问到这个变量，例如 main.js，App.vue 等


- process.env.NODE_ENV 的正确配置方式

```js
// 不好
process: {
    env: {
        NODE_ENV: JSON.stringify('production')
    }
}
// 因为会重写破坏原始的 process 对象，对象包含了当前进程的很多信息
process {
  title: 'node',
  version: 'v8.11.2',
  moduleLoadList: 
   [ 'Binding contextify',],
  versions: 
   { http_parser: '2.8.0'},
  arch: 'x64',
  platform: 'darwin',
  release: 
   { name: 'node' },
  argv: [ '/usr/local/bin/node' ],
  execAr,
  // ...
}
```

```js
// 不好
'process.env': {
    NODE_ENV: JSON.stringify('production')
}
// 因为会重写破坏原始的 process.env 对象，对象也包含了当前进程的很多信息
{ TERM: 'xterm-256color',
  SHELL: '/bin/bash',
  TMPDIR: '/var/folders/lw/rl5nyyrn4lb0rrpspv4szc3c0000gn/T/',
  Apple_PubSub_Socket_Render: '/private/tmp/com.apple.launchd.dEPuHtiDsx/Render',
  USER: 'frank',
  SSH_AUTH_SOCK: '/private/tmp/com.apple.launchd.MRVOOE7lpI/Listeners',
  __CF_USER_TEXT_ENCODING: '0x1F5:0x19:0x34',
  PATH: '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS',
  PWD: '/Users/frank/Desktop/corporation/weidian-crm',
  XPC_FLAGS: '0x0',
  XPC_SERVICE_NAME: '0',
  SHLVL: '1',
  HOME: '/Users/frank',
  LOGNAME: 'frank',
  LC_CTYPE: 'zh_CN.UTF-8',
  _: '/usr/local/bin/node'
}
```

```js
// 好
'process.env.NODE_ENV': JSON.stringify('production')
// 因为仅仅对NODE_ENV值进行修改，不会破坏完整进程，也不会破坏兼容性。
```


- vue-cli2.0配置
```js
const apiConfig = require('./config/api');
const webpackConfig = {
    plugins: [
        new webpack.DefinePlugin({
            API_CONFIG: JSON.stringify(apiConfig);
        })
    ]
}
```

- vue-cli3.0配置

```js
// webpack-chain
const apiConfig = require('./config/api');
// config.plugin('define')，实际上是 vue-service 内部创建的 webpack.DefinePlugin 实例的引用 ！
// 以后拓展 webpack 默认插件配置时，需要先到 vue-service 的源码中找找引用
module.exports = {
    chainWebpack: config => {
        config
            .plugin('define')
            .tap(args => { 
                args[0].API_CONFIG = JSON.stringify(apiConfig)
                return args
            })
    }
}
```


# 自动加载模块 ProvidePlugin

可以自动加载模块，不必到处 import 或 require

解决 Vue.prototype.xxx 和 import 和 require 重复引入的问题

- 使用三种方式

```js
// 直接引入整个库
new webpack.ProvidePlugin({
  $_guor: 'lodash',
});
```
```js
// 引入库的某个函数
new webpack.ProvidePlugin({
  $_uniqBy: ['lodash','uniqBy']
});
```

```js
// export default
new webpack.ProvidePlugin({
  Vue: ['vue/dist/vue.esm.js', 'default']
});
```

具体引入实践

1. webpack的plugins中增加$_的配置
```js
// webpack.base.config.js
plugins: [
    new webpack.ProvidePlugin({
      $_: 'lodash',
    }),
],
```
2. eslint的globals增加$_的配置
```js
// .eslintrc.js
globals: {
    $_: 'readonly', // 或者true
},
```
3. 在Vue中如何使用$_ 在Vue的template中使用的注意事项
```js
// script中直接使用 $_.uniqBy(...)
// <p>{{$_(...)}</p>
methods: {
  $_
}

// 为什么这个是最推荐的呢？
// 这是因为ProvidePlugin最终返回给我们的，是一个hooks函数。

hooks () {
  return hookCallback.apply(null, arguments);
}
// 既然是一个函数，那么它其实就是一个method。
// 由于需要在vue的template中使用，所以需要将其挂载到vue实例上。
// 因此直接在methods中绑定，挂载到vue示例。

// 那为什么不挂载到data上呢？
// 避免额外的无用的开销。
// 这是因为data是用来定义一些响应式的数据的，我们的$_只是一个工具函数，不会有双向绑定的事情发生在它身上，因此也不需要定义在data中，vue不用为其定义单独的watcher，dep，getter，setter等等。

```


- 思考

- 体积：使用ProvidePlugin后会比一直引入减小打包体积吗？ 不会。反而会略微增大一些，0.0X KB。

- 尽量定义出唯一性高的全局变量，例如$_,$moment

- 同一个前端小组的成员都采用全局变量的方式引入

- 最好是能维护一个全局变量的文档，在新人入职时特殊强调


# 限定查找 moment/locale 上下文里符合 /zh-cn/ 表达式的文件，因此也只会打包这几种本地化内容

```js
//webpack 配置
plugins: [
  //解决 moment 打包的时候把所有的语言都打包进去的问题
  new webpack.ContextReplacementPlugin(/moment[\\\/]locale$/, /^\.\/(zh-cn)$/)
]
```




# DLLPlugin

DLLPlugin 就是将包含大量复用模块且不会频繁更新的库进行编译，只需要编译一次，编译完成后存在指定的文件（这里可以称为动态链接库）中。在之后的构建过程中不会再对这些模块进行编译，而是直接使用 DllReferencePlugin 来引用动态链接库的代码。因此可以大大提高构建速度。一般会对常用的第三方模块使用这种方式，例如 react、react-dom、lodash 等等。只要这些模块不升级更新，这些动态链接库就不需要重新编译。

- 需要插件

Webpack 已经内置了对动态链接库的支持，需要通过两个内置插件的配合使用。它们分别是：

DllPlugin 插件：用于打包出一个个单独的动态链接库文件

DllReferencePlugin 插件：用于在主配置文件中去引入 DllPlugin 插件打包好的动态链接库文件


## 使用

1. 先编写一个配置文件专门用来编译生成动态链接库（使用 DllPlugin）

```js
// webpack_dll.config.js
const path = require('path');
const webpack = require('webpack');
const CleanWebpaclPlugin = require('clean-webpack-plugin');
const FirendlyErrorePlugin = require('friendly-errors-webpack-plugin');

module.exports = {
    mode: 'production',
    entry: {
        // 将 lodash 模块作为入口编译成动态链接库
        lodash: ['lodash']
    },
    output: {
        // 指定生成文件所在目录
        // 由于每次打包生产环境时会清空 dist 文件夹，因此这里我将它们存放在了 public 文件夹下
        path: path.resolve(__dirname, 'public/vendor'),
        // 指定文件名
        filename: '[name].dll.js',
        // 存放动态链接库的全局变量名称，例如对应 lodash 来说就是 lodash_dll_lib
        // 这个名称需要与 DllPlugin 插件中的 name 属性值对应起来
        // 之所以在前面 _dll_lib 是为了防止全局变量冲突
        library: '[name]_dll_lib'
    },
    plugins: [
        new CleanWebpaclPlugin(['vendor'], {
            root: path.resolve(__dirname, 'public')
        }),
        new FirendlyErrorePlugin(),
        
        // 接入 DllPlugin
        new webpack.DllPlugin({
            // 描述动态链接库的 manifest.json 文件输出时的文件名称
            // 由于每次打包生产环境时会清空 dist 文件夹，因此这里我将它们存放在了 public 文件夹下
            path: path.join(__dirname, 'public', 'vendor', '[name].manifest.json'),
            // 动态链接库的全局变量名称，需要和 output.library 中保持一致
            // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值
            // 例如 lodash.manifest.json 中就有 "name": "lodash_dll_lib"
            name: '[name]_dll_lib'
        })
    ]
}
```

2. 编写配置文件用来打包项目（使用 DllReferencePlugin）

```js
// webpack.config.js
const path = require('path');
const webpack = require('webpack');
const HTMLWebpackPlugin = require('html-webpack-plugin');
const CleanWebpaclPlugin = require('clean-webpack-plugin');
const FirendlyErrorePlugin = require('friendly-errors-webpack-plugin');

module.exports = {
    mode: 'production',
    devtool: 'source-map',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'build-[hash:5].js'
    },
    plugins: [
        new HTMLWebpackPlugin({
            title: 'Webpak DllPlugin 的使用',
            template: './public/index.html'
        }),
        new CleanWebpaclPlugin(['dist']),
        new FirendlyErrorePlugin(),
        new webpack.DefinePlugin({
            'process.env.NODE_ENV': JSON.stringify('production')
        }),
        // 告诉 Webpack 使用了哪些动态链接库
        new webpack.DllReferencePlugin({
            // 描述 lodash 动态链接库的文件内容
            manifest: require('./public/vendor/lodash.manifest.json')
        })
    ]
}
```


3. 在 index.html 文件中引入动态链接库

由于动态链接库我们一般只编译一次，之后就不用编译，复用模块都被打包到了动态链接库中，因此入口的 index.js 文件中已经不包含这些模块了，所以要在 index.html 中单独引入。

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Webpak DllPlugin 的使用</title>
</head>
<body>
    <div id="root"></div>
    <script src="../public/vendor/lodash.dll.js"></script>
</body>
</html>

```

4. 在 package.json 中添加两条指令：

```js
"scripts": {
    "build": "webpack --config webpack.config.js", // 打包项目
    // 生成动态链接库，只需要运行一次这个指令，以后打包项目不需要再执行这个指令
    "build:dll": "webpack --config webpack_dll.config.js"
}
```


## add-asset-html-webpack-plugin 的使用

因为打包的时候不能将动态链接库自动的存放到 dist 文件夹，也不能自动在 html 文件中引入动态链接库脚本。所以这时候 add-asset-html-webpack-plugin 就派上用场了。

```js
// $ npm install add-asset-html-webpack-plugin -D
```

```js
// webpack.config.js
...;
const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin');

module.exports = {
    ...,
    plugins: [
        ...,
        // 该插件将把给定的 JS 或 CSS 文件添加到 webpack 配置的文件中，并将其放入资源列表 html webpack插件注入到生成的 html 中。
        new AddAssetHtmlPlugin([
            {
                // 要添加到编译中的文件的绝对路径，以及生成的HTML文件。支持globby字符串
                filepath: require.resolve(path.resolve(__dirname, 'public/vendor/lodash.dll.js')),
                // 文件输出目录
                outputPath: 'vendor',
                // 脚本或链接标记的公共路径
                publicPath: 'vendor'
            }
        ])
    ]
}

// 最后就可以删掉 index.html 文件中手动引入的脚本了
<script src="../public/vendor/lodash.dll.js"></script>
```

## 总结

DllPlugin 用于打包出一个个单独的动态链接库文件并生成对应的主清单文件用于描述动态链接库中包含哪些模块

DllReferencePlugin 用于在主清单文件中去引入 DllPlugin 插件打包好的动态链接库文件

最后可以使用 AddAssetHtmlPlugin 将生成的动态链接库文件拷贝到出口文件夹下，然后 HTMLWebpackPlugin 就会自动的将脚本文件注入到生成的 html 文件中去

## 在 vue-cli3 中的配置
1. 新建一个webpack.dll.config.js
```js
// 定义常用对象
const path = require('path')
const webpack = require('webpack')
// clean-webpack-plugin 主要用于每次生成动态链接库时首先清空 vendor 目录
const CleanWebpackPlugin = require('clean-webpack-plugin')

// dll文件存放的目录 一般定义为 public/vendor
const dllPath = 'public/vendor'

module.exports = {
  // 定义提取哪些库/依赖
  entry: {
    // 该对象中，键名定义生成生成文件的前缀，键值为数组类型是依赖名
    // manifest.json 这个文件是用于让 DllReferencePlugin 能够映射到相应的依赖上
    vue: ["vue", "vue-router", "vuex", 'axios'], // vue-manifest.json
    antd: ["ant-design-vue"], // antd-manifest.json
    echarts: ["echarts"], // echarts-manifest.json
  },
  output: {
    path: path.join(__dirname, dllPath),
    filename: '[name].dll.js',
    // vendor.dll.js中暴露出的全局变量名
    // 保持与 webpack.DllPlugin 中名称一致
    library: '[name]_[hash]'
  },
  plugins: [
    // 清除之前的dll文件
    new CleanWebpackPlugin(['*.*'], {
      root: path.join(__dirname, dllPath)
    }),
    // 定义插件
    new webpack.DllPlugin({
      // manifest.json 文件的 绝对路径（输出文件）
      path: path.join(__dirname, dllPath, '[name]-manifest.json'),
      // 保持与 output.library 中名称一致
      name: '[name]_[hash]',
      context: process.cwd()
    })
  ]
}
```
2. DllReferencePlugin 配置

```js
// 此插件配置在 webpack 的主配置文件中，此插件会根据描述文件引用依赖到需要的预编译的依赖中
module.exports = {

  configureWebpack: config => {
    plugins: [
        // 避免在公共区域重复编译依赖
    	new webpack.DllReferencePlugin({
            context: process.cwd(),
            manifest: require(`./public/vendor/vue-manifest.json`)
        })
        new webpack.DllReferencePlugin({
            context: process.cwd(),
            manifest: require(`./public/vendor/antd-manifest.json`)
        })
        new webpack.DllReferencePlugin({
            context: process.cwd(),
            manifest: require(`./public/vendor/echarts-manifest.json`)
        })
    ]
  }
}

```

- DllReferencePlugin 循环优化

DllReferencePlugin 插件配置时代码存在重复，进行优化。 在 webpack.dll.config.js 文件中我们其实可以拿到所有的 name，即可以对其进行遍历生成。

```js
// vue.config.js
const DllConfig = require('./webpack.dll.config')

module.exports = {

    configureWebpack: config => {
    	let plugins = [
        	...
        ]
        // 避免在公共区域重复编译依赖
        Object.keys(DllConfig.entry).forEach(key=>{
          plugins.push(new webpack.DllReferencePlugin({
              context: process.cwd(),
              manifest: require(`./public/vendor/${key}-manifest.json`)
          }))
        })
        // 整合插件
    	config.plugins = [...config.plugins, ...plugins]
    }
    
}

```

3. index.html 配置

```js
<script src="/vendor/vue.dll.js"></script>
<script src="/vendor/antd.dll.js"></script>
<script src="/vendor/echarts.dll.js"></script>
```
- 引入优化

使用 add-asset-html-webpack-plugin 自动引入资源库

```js
module.exports = {

  configureWebpack: config => {
    plugins: [
        ...
        new HtmlWebpackPlugin({
          title: 'My Project',
          template: 'public/index.html',
          favicon: 'public/logo.png'
        })
        // 迁移到 webpack 4+ 后，需要在 HtmlWebpackPlugin 之后应用该插件
        new AddAssetHtmlPlugin({
          // dll 文件的位置，配置 *.js 可以使插件加载目录下的所有资源库 js 文件
          filepath: path.resolve(__dirname, './public/vendor/*.js'),
          // script 标签生成的 src 路径 dll 引用路径，请使用 绝对路径！！！
          publicPath: '/vendor',
          // dll最终输出的目录
          outputPath: './vendor'
        })
    ]
  }
  
}

```


## 整合配置

```js
// vue.config.js
const path = require('path')
const webpack = require('webpack')
const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const DllConfig = require('./webpack.dll.config')

module.exports = {
  ...
  configureWebpack: config => {
  
    let plugins = [
      new HtmlWebpackPlugin({
        title: 'My Project',
        template: 'public/index.html',
        favicon: 'public/logo.png'
      })
    ]
    
    if (process.env.NODE_ENV === 'production') {
      // 将生成的 dll 文件注入到 生成的 html 模板中
      plugins.push(new AddAssetHtmlPlugin({
        // dll文件位置
        filepath: path.resolve(__dirname, './public/vendor/*.js'),
        // dll 引用路径
        publicPath: '/vendor',
        // dll最终输出的目录
        outputPath: './vendor'
      }))
      // 避免在公共区域重复编译依赖
      Object.keys(DllConfig.entry).forEach(key=>{
        plugins.push(new webpack.DllReferencePlugin({
            context: process.cwd(),
            manifest: require(`./public/vendor/${key}-manifest.json`)
        }))
      })
    }
    
    // 整合插件
    config.plugins = [...config.plugins, ...plugins]
  }
  
}

```

```js
// webpack.dll.config.js
// 定义常用对象
const path = require('path')
const webpack = require('webpack')
const CleanWebpackPlugin = require('clean-webpack-plugin')

// dll文件存放的目录
const dllPath = 'public/vendor'

module.exports = {
  // 需要提取的库文件
  entry: {
    vue: ["vue", "vue-router", "vuex", 'axios'],
    antd: ["ant-design-vue"],
    echarts: ["echarts"],
  },
  output: {
    path: path.join(__dirname, dllPath),
    filename: '[name].dll.js',
    // vendor.dll.js中暴露出的全局变量名
    // 保持与 webpack.DllPlugin 中名称一致
    library: '[name]_[hash]'
  },
  plugins: [
    // 清除之前的dll文件
    new CleanWebpackPlugin(['*.*'], {
      root: path.join(__dirname, dllPath)
    }),
    // 定义插件
    new webpack.DllPlugin({
      path: path.join(__dirname, dllPath, '[name]-manifest.json'),
      // 保持与 output.library 中名称一致
      name: '[name]_[hash]',
      context: process.cwd()
    })
  ]
}

```