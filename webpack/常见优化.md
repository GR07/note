# 减少冗余辅助函数

babel-plugin-transform-runtime 是 Babel 官方提供的一个插件，把辅助函数代码变为 var _extent = require('babel-runtime/helpers/_extent');


# 图片转 base64 编码的字符串直接注入到代码

把图片转 base64 编码的字符串直接注入到代码，减少http请求


# 缩小文件搜索范围 include

Loader 对文件的转换操作很耗时，需要让尽可能少的文件被 Loader 处理。


# resolve.alias 配置路径别名


# 使用 HappyPack 多进程构建 vue-cli不支持

构建慢的问题会显得严重。 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。

把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。

注意是 多进程 不支持 多线程


# DllPlugin 动态链接库

将react和react-dom单独打包好，然后动态链接引入即可。如果第二次打包，那么发现react和react-dom已经被打包好了，那么就不需要再打包了，这样就大大提升了性能。




# 模块热更新插件 HotModuleReplacementPlugin

Hot-Module-Replacement 的热更新是依赖于 webpack-dev-server

后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，HMR 是只更新修改的部分。

- HotModuleReplacementPlugin 是 webpack 模块自带的，所以引入 webpack 后，在 plugins 配置项中直接使用即可。

```js
const webpack = require('webpack')

plugins: [
  new webpack.HotModuleReplacementPlugin(), // 热更新插件
]
```


# 生成 html 文件 htmlWebpackPlugin

把打包后的 js 文件 和 extract-text-webpack-plugin 抽取的 css 样式文件，

然后在html-webpack-plugin插件的指定的html模板基础上，插入样式link到head元素中，插入script到head或者body中，最后生成一个 html 文件。

创建了一个全新的 html文件，所有的 bundle 会自动添加到 html 中

解决的问题：当改了打包出口文件名后，可以动态把打包后的文件自动添加到 html 中


```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

plugins: [
  new HtmlWebpackPlugin({
    filename: 'index.html',
    template: path.join(__dirname, '/index.html'),
    minify: {
      // 压缩HTML文件
      removeComments: true, // 移除HTML中的注释
      collapseWhitespace: true, // 删除空白符与换行符
      minifyCSS: true, // 压缩内联css
    },
    // inject 有四个选项值 如下
    inject: true,
  }),
]
// true：默认值，script 标签位于 html 文件的 body 底部
// body：script 标签位于 html 文件的 body 底部（同 true）
// head：script 标签位于 head 标签内
// false：不插入生成的 js 文件，只是单纯的生成一个 html 文件
```

```js
// 多页应用
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  entry: {
    index: './src/index.js',
    login: './src/login.js',
  },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[hash:6].js',
  },
  //...
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      filename: 'index.html', //打包后的文件名
      // 这样执行 npm run build，可以看到 index.html 中仅引入了 index 的 js 文件
      chunks: ['index'],
    }),
    new HtmlWebpackPlugin({
      template: './public/login.html',
      filename: 'login.html', //打包后的文件名
      // 这样执行 npm run build，可以看到 index.html 中仅引入了 login 的 js 文件
      chunks: ['login'],
    }),
  ],
}
```


# clean-webpack-plugin

清理 /dist 文件夹

解决的问题：反复打包后，dist目录会有很多历史打包文件，在每次构建前清理 /dist 文件夹。

使用注意：
```js
// 官方文档是错误的示范，需要解构一下，不需传参直接实例化即可。
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
plugins: [
    // cleanStaleWebpackAssets: false 告诉插件删除文件的同时不要删除没有改变的文件
    new CleanWebpackPlugin({ cleanStaleWebpackAssets: false })
]
```


# 分离css文件 插件 mini-css-extract-plugin

不分离的时候，打包后css代码会混合在js代码中
```js
// 例如 color: blue;
___CSS_LOADER_EXPORT___.push([module.i, \"body {\\r\\n    color: blue;\\r\\n}\", \"\"]);
```

使用 npm install --save-dev mini-css-extract-plugin

主要是为了抽离css样式，防止将样式打包在js中引起页面样式加载错乱的现象。



将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 sourceMap。只能用在 webpack4 中

这个插件应该只用在生产环境配置，并且在 loaders 链中不使用 style-loader, 而且这个插件暂时不支持 HotModuleReplacementPlugin(模块热更新插件)

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  module: {
    rules: [
      {
        test: /\.(le|c)ss$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: '../',
            },
          },
          'css-loader',
          'postcss-loader',
          'less-loader',
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'css/[name].[contenthash:8].css',
      chunkFilename: 'css/[id].[contenthash:8].css',
    }),
  ],
}
```



# 去除重复 CSS 代码 purifycss-webpack

有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。

```js
const path = require('path')
const PurifyCssWebpack = require('purifycss-webpack') // 引入PurifyCssWebpack插件
const glob = require('glob') // 引入glob模块,用于扫描全部html文件中所引用的css

module.exports = merge(common, {
  plugins: [
    new PurifyCssWebpack({
      paths: glob.sync(path.join(__dirname, 'src/*.html')),
    }),
  ],
})
```


# 压缩 CSS 文件 optimize-css-assets-webpack-plugin

希望减小 css 打包后的体积

```js
const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin") // 压缩css代码

optimization: {
  minimizer: [
    // 压缩css
    new OptimizeCSSAssetsPlugin({})
  ]
}
```



# 压缩 JS 文件 UglifyJsPlugin

uglifyJsPlugin 是 vue-cli 默认使用的压缩代码方式，用来对 js 文件进行压缩，

1. 从而减小 js 文件的大小，加速 load 速度。

2. 也有利于系统代码安全；

3. 清除打印日志和debugger信息

它使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。

配置SplitChunks 抽取公有代码，提升你的应用的性能

从 webpack 4 开始，也可以通过 "mode" 配置选项轻松切换到压缩输出，只需设置为 "production"。

```js
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')

plugins: [
  new UglifyJsPlugin({
    uglifyOptions: {
      compress: {
        warnings: false
      }
    },
    sourceMap: true,  // 是否启用文件缓存
    parallel: true   // 使用多进程并行运行来提高构建速度
  })
]
```


# 压缩 JS 文件 terser-webpack-plugin

Webpack4.0 默认是使用 terser-webpack-plugin 这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel 参数，使用多进程压缩，加快压缩。

```js
const TerserPlugin = require('terser-webpack-plugin') // 压缩js代码

optimization: {
  minimizer: [
    new TerserPlugin({
      parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1
      cache: true, // 是否缓存
      sourceMap: false,
    }),
  ]
}
```



# 为 压缩代码 增加多进程 ParallelUglifyPlugin

开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。

```js
const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')

plugins: [
  new ParallelUglifyPlugin({
    //cacheDir 用于配置缓存存放的目录路径。
    cacheDir: '.cache/',
    sourceMap: true,
    uglifyJS: {
      output: {
        comments: false,
      },
      compress: {
        warnings: false,
      },
    },
  }),
]
```


# gzip 压缩 compression-webpack-plugin

所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。

gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。

当然，这个方法还需要后端配置支持。

```js
const CompressionPlugin = require('compression-webpack-plugin')

plugins: [
  new CompressionPlugin({
    // gzip压缩配置
    test: /\.js$|\.html$|\.css/, // 匹配文件名
    threshold: 10240, // 对超过10kb的数据进行压缩
    deleteOriginalAssets: false, // 是否删除原文件
  }),
]

// 使用异常报错：Cannot read property ‘tapPromise‘ of undefined

// 卸载高版本 npm uninstall compression-webpack-plugin

// 安装低版本 npm i compression-webpack-plugin@5.0.1
```